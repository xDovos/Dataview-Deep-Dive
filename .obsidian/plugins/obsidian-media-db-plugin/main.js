/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/main.ts
__export(exports, {
  default: () => MediaDbPlugin
});
var import_obsidian17 = __toModule(require("obsidian"));

// src/settings/Settings.ts
var import_obsidian6 = __toModule(require("obsidian"));

// src/settings/suggesters/FolderSuggest.ts
var import_obsidian2 = __toModule(require("obsidian"));

// src/settings/suggesters/Suggest.ts
var import_obsidian = __toModule(require("obsidian"));

// node_modules/@popperjs/core/lib/enums.js
var top = "top";
var bottom = "bottom";
var right = "right";
var left = "left";
var auto = "auto";
var basePlacements = [top, bottom, right, left];
var start = "start";
var end = "end";
var clippingParents = "clippingParents";
var viewport = "viewport";
var popper = "popper";
var reference = "reference";
var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []);
var beforeRead = "beforeRead";
var read = "read";
var afterRead = "afterRead";
var beforeMain = "beforeMain";
var main = "main";
var afterMain = "afterMain";
var beforeWrite = "beforeWrite";
var write = "write";
var afterWrite = "afterWrite";
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

// node_modules/@popperjs/core/lib/dom-utils/getNodeName.js
function getNodeName(element2) {
  return element2 ? (element2.nodeName || "").toLowerCase() : null;
}

// node_modules/@popperjs/core/lib/dom-utils/getWindow.js
function getWindow(node) {
  if (node == null) {
    return window;
  }
  if (node.toString() !== "[object Window]") {
    var ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }
  return node;
}

// node_modules/@popperjs/core/lib/dom-utils/instanceOf.js
function isElement(node) {
  var OwnElement = getWindow(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}
function isHTMLElement(node) {
  var OwnElement = getWindow(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}
function isShadowRoot(node) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  var OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}

// node_modules/@popperjs/core/lib/modifiers/applyStyles.js
function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function(name) {
    var style = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element2 = state.elements[name];
    if (!isHTMLElement(element2) || !getNodeName(element2)) {
      return;
    }
    Object.assign(element2.style, style);
    Object.keys(attributes).forEach(function(name2) {
      var value = attributes[name2];
      if (value === false) {
        element2.removeAttribute(name2);
      } else {
        element2.setAttribute(name2, value === true ? "" : value);
      }
    });
  });
}
function effect(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;
  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }
  return function() {
    Object.keys(state.elements).forEach(function(name) {
      var element2 = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
      var style = styleProperties.reduce(function(style2, property) {
        style2[property] = "";
        return style2;
      }, {});
      if (!isHTMLElement(element2) || !getNodeName(element2)) {
        return;
      }
      Object.assign(element2.style, style);
      Object.keys(attributes).forEach(function(attribute) {
        element2.removeAttribute(attribute);
      });
    });
  };
}
var applyStyles_default = {
  name: "applyStyles",
  enabled: true,
  phase: "write",
  fn: applyStyles,
  effect,
  requires: ["computeStyles"]
};

// node_modules/@popperjs/core/lib/utils/getBasePlacement.js
function getBasePlacement(placement) {
  return placement.split("-")[0];
}

// node_modules/@popperjs/core/lib/utils/math.js
var max = Math.max;
var min = Math.min;
var round = Math.round;

// node_modules/@popperjs/core/lib/utils/userAgent.js
function getUAString() {
  var uaData = navigator.userAgentData;
  if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
    return uaData.brands.map(function(item) {
      return item.brand + "/" + item.version;
    }).join(" ");
  }
  return navigator.userAgent;
}

// node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js
function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test(getUAString());
}

// node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js
function getBoundingClientRect(element2, includeScale, isFixedStrategy) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  var clientRect = element2.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;
  if (includeScale && isHTMLElement(element2)) {
    scaleX = element2.offsetWidth > 0 ? round(clientRect.width) / element2.offsetWidth || 1 : 1;
    scaleY = element2.offsetHeight > 0 ? round(clientRect.height) / element2.offsetHeight || 1 : 1;
  }
  var _ref = isElement(element2) ? getWindow(element2) : window, visualViewport = _ref.visualViewport;
  var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
  var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
  var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
  var width = clientRect.width / scaleX;
  var height = clientRect.height / scaleY;
  return {
    width,
    height,
    top: y,
    right: x + width,
    bottom: y + height,
    left: x,
    x,
    y
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js
function getLayoutRect(element2) {
  var clientRect = getBoundingClientRect(element2);
  var width = element2.offsetWidth;
  var height = element2.offsetHeight;
  if (Math.abs(clientRect.width - width) <= 1) {
    width = clientRect.width;
  }
  if (Math.abs(clientRect.height - height) <= 1) {
    height = clientRect.height;
  }
  return {
    x: element2.offsetLeft,
    y: element2.offsetTop,
    width,
    height
  };
}

// node_modules/@popperjs/core/lib/dom-utils/contains.js
function contains(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode();
  if (parent.contains(child)) {
    return true;
  } else if (rootNode && isShadowRoot(rootNode)) {
    var next = child;
    do {
      if (next && parent.isSameNode(next)) {
        return true;
      }
      next = next.parentNode || next.host;
    } while (next);
  }
  return false;
}

// node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js
function getComputedStyle2(element2) {
  return getWindow(element2).getComputedStyle(element2);
}

// node_modules/@popperjs/core/lib/dom-utils/isTableElement.js
function isTableElement(element2) {
  return ["table", "td", "th"].indexOf(getNodeName(element2)) >= 0;
}

// node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js
function getDocumentElement(element2) {
  return ((isElement(element2) ? element2.ownerDocument : element2.document) || window.document).documentElement;
}

// node_modules/@popperjs/core/lib/dom-utils/getParentNode.js
function getParentNode(element2) {
  if (getNodeName(element2) === "html") {
    return element2;
  }
  return element2.assignedSlot || element2.parentNode || (isShadowRoot(element2) ? element2.host : null) || getDocumentElement(element2);
}

// node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js
function getTrueOffsetParent(element2) {
  if (!isHTMLElement(element2) || getComputedStyle2(element2).position === "fixed") {
    return null;
  }
  return element2.offsetParent;
}
function getContainingBlock(element2) {
  var isFirefox = /firefox/i.test(getUAString());
  var isIE = /Trident/i.test(getUAString());
  if (isIE && isHTMLElement(element2)) {
    var elementCss = getComputedStyle2(element2);
    if (elementCss.position === "fixed") {
      return null;
    }
  }
  var currentNode = getParentNode(element2);
  if (isShadowRoot(currentNode)) {
    currentNode = currentNode.host;
  }
  while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
    var css = getComputedStyle2(currentNode);
    if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === "filter" || isFirefox && css.filter && css.filter !== "none") {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent(element2) {
  var window2 = getWindow(element2);
  var offsetParent = getTrueOffsetParent(element2);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle2(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle2(offsetParent).position === "static")) {
    return window2;
  }
  return offsetParent || getContainingBlock(element2) || window2;
}

// node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
}

// node_modules/@popperjs/core/lib/utils/within.js
function within(min2, value, max2) {
  return max(min2, min(value, max2));
}
function withinMaxClamp(min2, value, max2) {
  var v = within(min2, value, max2);
  return v > max2 ? max2 : v;
}

// node_modules/@popperjs/core/lib/utils/getFreshSideObject.js
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}

// node_modules/@popperjs/core/lib/utils/mergePaddingObject.js
function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}

// node_modules/@popperjs/core/lib/utils/expandToHashMap.js
function expandToHashMap(value, keys) {
  return keys.reduce(function(hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}

// node_modules/@popperjs/core/lib/modifiers/arrow.js
var toPaddingObject = function toPaddingObject2(padding, state) {
  padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding;
  return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
};
function arrow(_ref) {
  var _state$modifiersData$;
  var state = _ref.state, name = _ref.name, options = _ref.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement(state.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= 0;
  var len = isVertical ? "height" : "width";
  if (!arrowElement || !popperOffsets2) {
    return;
  }
  var paddingObject = toPaddingObject(options.padding, state);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === "y" ? top : left;
  var maxProp = axis === "y" ? bottom : right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
  var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent(arrowElement);
  var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2;
  var min2 = paddingObject[minProp];
  var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset2 = within(min2, center, max2);
  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
}
function effect2(_ref2) {
  var state = _ref2.state, options = _ref2.options;
  var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
  if (arrowElement == null) {
    return;
  }
  if (typeof arrowElement === "string") {
    arrowElement = state.elements.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return;
    }
  }
  if (!contains(state.elements.popper, arrowElement)) {
    return;
  }
  state.elements.arrow = arrowElement;
}
var arrow_default = {
  name: "arrow",
  enabled: true,
  phase: "main",
  fn: arrow,
  effect: effect2,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};

// node_modules/@popperjs/core/lib/utils/getVariation.js
function getVariation(placement) {
  return placement.split("-")[1];
}

// node_modules/@popperjs/core/lib/modifiers/computeStyles.js
var unsetSides = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function roundOffsetsByDPR(_ref, win) {
  var x = _ref.x, y = _ref.y;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: round(x * dpr) / dpr || 0,
    y: round(y * dpr) / dpr || 0
  };
}
function mapToStyles(_ref2) {
  var _Object$assign2;
  var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
  var _offsets$x = offsets.x, x = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y = _offsets$y === void 0 ? 0 : _offsets$y;
  var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
    x,
    y
  }) : {
    x,
    y
  };
  x = _ref3.x;
  y = _ref3.y;
  var hasX = offsets.hasOwnProperty("x");
  var hasY = offsets.hasOwnProperty("y");
  var sideX = left;
  var sideY = top;
  var win = window;
  if (adaptive) {
    var offsetParent = getOffsetParent(popper2);
    var heightProp = "clientHeight";
    var widthProp = "clientWidth";
    if (offsetParent === getWindow(popper2)) {
      offsetParent = getDocumentElement(popper2);
      if (getComputedStyle2(offsetParent).position !== "static" && position === "absolute") {
        heightProp = "scrollHeight";
        widthProp = "scrollWidth";
      }
    }
    offsetParent = offsetParent;
    if (placement === top || (placement === left || placement === right) && variation === end) {
      sideY = bottom;
      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : offsetParent[heightProp];
      y -= offsetY - popperRect.height;
      y *= gpuAcceleration ? 1 : -1;
    }
    if (placement === left || (placement === top || placement === bottom) && variation === end) {
      sideX = right;
      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : offsetParent[widthProp];
      x -= offsetX - popperRect.width;
      x *= gpuAcceleration ? 1 : -1;
    }
  }
  var commonStyles = Object.assign({
    position
  }, adaptive && unsetSides);
  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x,
    y
  }, getWindow(popper2)) : {
    x,
    y
  };
  x = _ref4.x;
  y = _ref4.y;
  if (gpuAcceleration) {
    var _Object$assign;
    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
  }
  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : "", _Object$assign2[sideX] = hasX ? x + "px" : "", _Object$assign2.transform = "", _Object$assign2));
}
function computeStyles(_ref5) {
  var state = _ref5.state, options = _ref5.options;
  var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  var commonStyles = {
    placement: getBasePlacement(state.placement),
    variation: getVariation(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration,
    isFixed: state.options.strategy === "fixed"
  };
  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive,
      roundOffsets
    })));
  }
  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: "absolute",
      adaptive: false,
      roundOffsets
    })));
  }
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-placement": state.placement
  });
}
var computeStyles_default = {
  name: "computeStyles",
  enabled: true,
  phase: "beforeWrite",
  fn: computeStyles,
  data: {}
};

// node_modules/@popperjs/core/lib/modifiers/eventListeners.js
var passive = {
  passive: true
};
function effect3(_ref) {
  var state = _ref.state, instance4 = _ref.instance, options = _ref.options;
  var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
  var window2 = getWindow(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
  if (scroll) {
    scrollParents.forEach(function(scrollParent) {
      scrollParent.addEventListener("scroll", instance4.update, passive);
    });
  }
  if (resize) {
    window2.addEventListener("resize", instance4.update, passive);
  }
  return function() {
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.removeEventListener("scroll", instance4.update, passive);
      });
    }
    if (resize) {
      window2.removeEventListener("resize", instance4.update, passive);
    }
  };
}
var eventListeners_default = {
  name: "eventListeners",
  enabled: true,
  phase: "write",
  fn: function fn() {
  },
  effect: effect3,
  data: {}
};

// node_modules/@popperjs/core/lib/utils/getOppositePlacement.js
var hash = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function(matched) {
    return hash[matched];
  });
}

// node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js
var hash2 = {
  start: "end",
  end: "start"
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function(matched) {
    return hash2[matched];
  });
}

// node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js
function getWindowScroll(node) {
  var win = getWindow(node);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft,
    scrollTop
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js
function getWindowScrollBarX(element2) {
  return getBoundingClientRect(getDocumentElement(element2)).left + getWindowScroll(element2).scrollLeft;
}

// node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js
function getViewportRect(element2, strategy) {
  var win = getWindow(element2);
  var html = getDocumentElement(element2);
  var visualViewport = win.visualViewport;
  var width = html.clientWidth;
  var height = html.clientHeight;
  var x = 0;
  var y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    var layoutViewport = isLayoutViewport();
    if (layoutViewport || !layoutViewport && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x + getWindowScrollBarX(element2),
    y
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js
function getDocumentRect(element2) {
  var _element$ownerDocumen;
  var html = getDocumentElement(element2);
  var winScroll = getWindowScroll(element2);
  var body = (_element$ownerDocumen = element2.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x = -winScroll.scrollLeft + getWindowScrollBarX(element2);
  var y = -winScroll.scrollTop;
  if (getComputedStyle2(body || html).direction === "rtl") {
    x += max(html.clientWidth, body ? body.clientWidth : 0) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}

// node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js
function isScrollParent(element2) {
  var _getComputedStyle = getComputedStyle2(element2), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}

// node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js
function getScrollParent(node) {
  if (["html", "body", "#document"].indexOf(getNodeName(node)) >= 0) {
    return node.ownerDocument.body;
  }
  if (isHTMLElement(node) && isScrollParent(node)) {
    return node;
  }
  return getScrollParent(getParentNode(node));
}

// node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js
function listScrollParents(element2, list) {
  var _element$ownerDocumen;
  if (list === void 0) {
    list = [];
  }
  var scrollParent = getScrollParent(element2);
  var isBody = scrollParent === ((_element$ownerDocumen = element2.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : updatedList.concat(listScrollParents(getParentNode(target)));
}

// node_modules/@popperjs/core/lib/utils/rectToClientRect.js
function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}

// node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js
function getInnerBoundingClientRect(element2, strategy) {
  var rect = getBoundingClientRect(element2, false, strategy === "fixed");
  rect.top = rect.top + element2.clientTop;
  rect.left = rect.left + element2.clientLeft;
  rect.bottom = rect.top + element2.clientHeight;
  rect.right = rect.left + element2.clientWidth;
  rect.width = element2.clientWidth;
  rect.height = element2.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
function getClientRectFromMixedType(element2, clippingParent, strategy) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element2, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element2)));
}
function getClippingParents(element2) {
  var clippingParents2 = listScrollParents(getParentNode(element2));
  var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle2(element2).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement(element2) ? getOffsetParent(element2) : element2;
  if (!isElement(clipperElement)) {
    return [];
  }
  return clippingParents2.filter(function(clippingParent) {
    return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
  });
}
function getClippingRect(element2, boundary, rootBoundary, strategy) {
  var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element2) : [].concat(boundary);
  var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents2[0];
  var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element2, clippingParent, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element2, firstClippingParent, strategy));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}

// node_modules/@popperjs/core/lib/utils/computeOffsets.js
function computeOffsets(_ref) {
  var reference2 = _ref.reference, element2 = _ref.element, placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference2.x + reference2.width / 2 - element2.width / 2;
  var commonY = reference2.y + reference2.height / 2 - element2.height / 2;
  var offsets;
  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference2.y - element2.height
      };
      break;
    case bottom:
      offsets = {
        x: commonX,
        y: reference2.y + reference2.height
      };
      break;
    case right:
      offsets = {
        x: reference2.x + reference2.width,
        y: commonY
      };
      break;
    case left:
      offsets = {
        x: reference2.x - element2.width,
        y: commonY
      };
      break;
    default:
      offsets = {
        x: reference2.x,
        y: reference2.y
      };
  }
  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
  if (mainAxis != null) {
    var len = mainAxis === "y" ? "height" : "width";
    switch (variation) {
      case start:
        offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element2[len] / 2);
        break;
      case end:
        offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element2[len] / 2);
        break;
      default:
    }
  }
  return offsets;
}

// node_modules/@popperjs/core/lib/utils/detectOverflow.js
function detectOverflow(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var popperRect = state.rects.popper;
  var element2 = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect(isElement(element2) ? element2 : element2.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
  var referenceClientRect = getBoundingClientRect(state.elements.reference);
  var popperOffsets2 = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: "absolute",
    placement
  });
  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset;
  if (elementContext === popper && offsetData) {
    var offset2 = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function(key) {
      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
      overflowOffsets[key] += offset2[axis] * multiply;
    });
  }
  return overflowOffsets;
}

// node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js
function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements2 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
    return getVariation(placement2) === variation;
  }) : basePlacements;
  var allowedPlacements = placements2.filter(function(placement2) {
    return allowedAutoPlacements.indexOf(placement2) >= 0;
  });
  if (allowedPlacements.length === 0) {
    allowedPlacements = placements2;
  }
  var overflows = allowedPlacements.reduce(function(acc, placement2) {
    acc[placement2] = detectOverflow(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding
    })[getBasePlacement(placement2)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function(a, b) {
    return overflows[a] - overflows[b];
  });
}

// node_modules/@popperjs/core/lib/modifiers/flip.js
function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement(placement) === auto) {
    return [];
  }
  var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}
function flip(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  if (state.modifiersData[name]._skip) {
    return;
  }
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = getBasePlacement(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
    return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding,
      flipVariations,
      allowedAutoPlacements
    }) : placement2);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements2[0];
  for (var i = 0; i < placements2.length; i++) {
    var placement = placements2[i];
    var _basePlacement = getBasePlacement(placement);
    var isStartVariation = getVariation(placement) === start;
    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? "width" : "height";
    var overflow = detectOverflow(state, {
      placement,
      boundary,
      rootBoundary,
      altBoundary,
      padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }
    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks = [];
    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }
    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }
    if (checks.every(function(check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }
    checksMap.set(placement, checks);
  }
  if (makeFallbackChecks) {
    var numberOfChecks = flipVariations ? 3 : 1;
    var _loop = function _loop2(_i2) {
      var fittingPlacement = placements2.find(function(placement2) {
        var checks2 = checksMap.get(placement2);
        if (checks2) {
          return checks2.slice(0, _i2).every(function(check) {
            return check;
          });
        }
      });
      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };
    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);
      if (_ret === "break")
        break;
    }
  }
  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
}
var flip_default = {
  name: "flip",
  enabled: true,
  phase: "main",
  fn: flip,
  requiresIfExists: ["offset"],
  data: {
    _skip: false
  }
};

// node_modules/@popperjs/core/lib/modifiers/hide.js
function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }
  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}
function isAnySideFullyClipped(overflow) {
  return [top, right, bottom, left].some(function(side) {
    return overflow[side] >= 0;
  });
}
function hide(_ref) {
  var state = _ref.state, name = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow(state, {
    elementContext: "reference"
  });
  var popperAltOverflow = detectOverflow(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets,
    popperEscapeOffsets,
    isReferenceHidden,
    hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-reference-hidden": isReferenceHidden,
    "data-popper-escaped": hasPopperEscaped
  });
}
var hide_default = {
  name: "hide",
  enabled: true,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: hide
};

// node_modules/@popperjs/core/lib/modifiers/offset.js
function distanceAndSkiddingToXY(placement, rects, offset2) {
  var basePlacement = getBasePlacement(placement);
  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
  var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
    placement
  })) : offset2, skidding = _ref[0], distance = _ref[1];
  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}
function offset(_ref2) {
  var state = _ref2.state, options = _ref2.options, name = _ref2.name;
  var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = placements.reduce(function(acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement], x = _data$state$placement.x, y = _data$state$placement.y;
  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x;
    state.modifiersData.popperOffsets.y += y;
  }
  state.modifiersData[name] = data;
}
var offset_default = {
  name: "offset",
  enabled: true,
  phase: "main",
  requires: ["popperOffsets"],
  fn: offset
};

// node_modules/@popperjs/core/lib/modifiers/popperOffsets.js
function popperOffsets(_ref) {
  var state = _ref.state, name = _ref.name;
  state.modifiersData[name] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: "absolute",
    placement: state.placement
  });
}
var popperOffsets_default = {
  name: "popperOffsets",
  enabled: true,
  phase: "read",
  fn: popperOffsets,
  data: {}
};

// node_modules/@popperjs/core/lib/utils/getAltAxis.js
function getAltAxis(axis) {
  return axis === "x" ? "y" : "x";
}

// node_modules/@popperjs/core/lib/modifiers/preventOverflow.js
function preventOverflow(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = detectOverflow(state, {
    boundary,
    rootBoundary,
    padding,
    altBoundary
  });
  var basePlacement = getBasePlacement(state.placement);
  var variation = getVariation(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
  var data = {
    x: 0,
    y: 0
  };
  if (!popperOffsets2) {
    return;
  }
  if (checkMainAxis) {
    var _offsetModifierState$;
    var mainSide = mainAxis === "y" ? top : left;
    var altSide = mainAxis === "y" ? bottom : right;
    var len = mainAxis === "y" ? "height" : "width";
    var offset2 = popperOffsets2[mainAxis];
    var min2 = offset2 + overflow[mainSide];
    var max2 = offset2 - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide];
    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset2 + maxOffset - offsetModifierValue;
    var preventedOffset = within(tether ? min(min2, tetherMin) : min2, offset2, tether ? max(max2, tetherMax) : max2);
    popperOffsets2[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset2;
  }
  if (checkAltAxis) {
    var _offsetModifierState$2;
    var _mainSide = mainAxis === "x" ? top : left;
    var _altSide = mainAxis === "x" ? bottom : right;
    var _offset = popperOffsets2[altAxis];
    var _len = altAxis === "y" ? "height" : "width";
    var _min = _offset + overflow[_mainSide];
    var _max = _offset - overflow[_altSide];
    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
    popperOffsets2[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }
  state.modifiersData[name] = data;
}
var preventOverflow_default = {
  name: "preventOverflow",
  enabled: true,
  phase: "main",
  fn: preventOverflow,
  requiresIfExists: ["offset"]
};

// node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js
function getHTMLElementScroll(element2) {
  return {
    scrollLeft: element2.scrollLeft,
    scrollTop: element2.scrollTop
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js
function getNodeScroll(node) {
  if (node === getWindow(node) || !isHTMLElement(node)) {
    return getWindowScroll(node);
  } else {
    return getHTMLElementScroll(node);
  }
}

// node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js
function isElementScaled(element2) {
  var rect = element2.getBoundingClientRect();
  var scaleX = round(rect.width) / element2.offsetWidth || 1;
  var scaleY = round(rect.height) / element2.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
}
function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  var isOffsetParentAnElement = isHTMLElement(offsetParent);
  var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
  var documentElement = getDocumentElement(offsetParent);
  var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}

// node_modules/@popperjs/core/lib/utils/orderModifiers.js
function order(modifiers) {
  var map = new Map();
  var visited = new Set();
  var result = [];
  modifiers.forEach(function(modifier) {
    map.set(modifier.name, modifier);
  });
  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function(dep) {
      if (!visited.has(dep)) {
        var depModifier = map.get(dep);
        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }
  modifiers.forEach(function(modifier) {
    if (!visited.has(modifier.name)) {
      sort(modifier);
    }
  });
  return result;
}
function orderModifiers(modifiers) {
  var orderedModifiers = order(modifiers);
  return modifierPhases.reduce(function(acc, phase) {
    return acc.concat(orderedModifiers.filter(function(modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}

// node_modules/@popperjs/core/lib/utils/debounce.js
function debounce(fn2) {
  var pending;
  return function() {
    if (!pending) {
      pending = new Promise(function(resolve) {
        Promise.resolve().then(function() {
          pending = void 0;
          resolve(fn2());
        });
      });
    }
    return pending;
  };
}

// node_modules/@popperjs/core/lib/utils/mergeByName.js
function mergeByName(modifiers) {
  var merged = modifiers.reduce(function(merged2, current) {
    var existing = merged2[current.name];
    merged2[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged2;
  }, {});
  return Object.keys(merged).map(function(key) {
    return merged[key];
  });
}

// node_modules/@popperjs/core/lib/createPopper.js
var DEFAULT_OPTIONS = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return !args.some(function(element2) {
    return !(element2 && typeof element2.getBoundingClientRect === "function");
  });
}
function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }
  var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper2(reference2, popper2, options) {
    if (options === void 0) {
      options = defaultOptions;
    }
    var state = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
      modifiersData: {},
      elements: {
        reference: reference2,
        popper: popper2
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance4 = {
      state,
      setOptions: function setOptions(setOptionsAction) {
        var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions, state.options, options2);
        state.scrollParents = {
          reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
          popper: listScrollParents(popper2)
        };
        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state.options.modifiers)));
        state.orderedModifiers = orderedModifiers.filter(function(m) {
          return m.enabled;
        });
        runModifierEffects();
        return instance4.update();
      },
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }
        var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
        if (!areValidElements(reference3, popper3)) {
          return;
        }
        state.rects = {
          reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
          popper: getLayoutRect(popper3)
        };
        state.reset = false;
        state.placement = state.options.placement;
        state.orderedModifiers.forEach(function(modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        for (var index = 0; index < state.orderedModifiers.length; index++) {
          if (state.reset === true) {
            state.reset = false;
            index = -1;
            continue;
          }
          var _state$orderedModifie = state.orderedModifiers[index], fn2 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
          if (typeof fn2 === "function") {
            state = fn2({
              state,
              options: _options,
              name,
              instance: instance4
            }) || state;
          }
        }
      },
      update: debounce(function() {
        return new Promise(function(resolve) {
          instance4.forceUpdate();
          resolve(state);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };
    if (!areValidElements(reference2, popper2)) {
      return instance4;
    }
    instance4.setOptions(options).then(function(state2) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state2);
      }
    });
    function runModifierEffects() {
      state.orderedModifiers.forEach(function(_ref) {
        var name = _ref.name, _ref$options = _ref.options, options2 = _ref$options === void 0 ? {} : _ref$options, effect4 = _ref.effect;
        if (typeof effect4 === "function") {
          var cleanupFn = effect4({
            state,
            name,
            instance: instance4,
            options: options2
          });
          var noopFn = function noopFn2() {
          };
          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }
    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function(fn2) {
        return fn2();
      });
      effectCleanupFns = [];
    }
    return instance4;
  };
}

// node_modules/@popperjs/core/lib/popper.js
var defaultModifiers = [eventListeners_default, popperOffsets_default, computeStyles_default, applyStyles_default, offset_default, flip_default, preventOverflow_default, arrow_default, hide_default];
var createPopper = /* @__PURE__ */ popperGenerator({
  defaultModifiers
});

// src/utils/Utils.ts
var pluginName = "obsidian-media-db-plugin";
var contactEmail = "m.projects.code@gmail.com";
var mediaDbTag = "mediaDB";
var mediaDbVersion = "0.5.2";
function wrapAround(value, size) {
  if (size <= 0) {
    throw Error("size may not be zero or negative");
  }
  return mod(value, size);
}
function containsOnlyLettersAndUnderscores(str) {
  return /^[a-zA-Z_]+$/.test(str);
}
function replaceIllegalFileNameCharactersInString(string) {
  return string.replace(/[\\,#%&{}/*<>$"@.?]*/g, "").replace(/:+/g, " -");
}
function replaceTags(template, mediaTypeModel) {
  return template.replace(new RegExp("{{.*?}}", "g"), (match) => replaceTag(match, mediaTypeModel));
}
function replaceTag(match, mediaTypeModel) {
  let tag = match;
  tag = tag.substring(2);
  tag = tag.substring(0, tag.length - 2);
  tag = tag.trim();
  const parts = tag.split(":");
  if (parts.length === 1) {
    const path = parts[0].split(".");
    const obj = traverseMetaData(path, mediaTypeModel);
    if (obj === void 0) {
      return "{{ INVALID TEMPLATE TAG - object undefined }}";
    }
    return obj;
  } else if (parts.length === 2) {
    const operator = parts[0];
    const path = parts[1].split(".");
    const obj = traverseMetaData(path, mediaTypeModel);
    if (obj === void 0) {
      return "{{ INVALID TEMPLATE TAG - object undefined }}";
    }
    if (operator === "LIST") {
      if (!Array.isArray(obj)) {
        return "{{ INVALID TEMPLATE TAG - operator LIST is only applicable on an array }}";
      }
      return obj.map((e) => `- ${e}`).join("\n");
    } else if (operator === "ENUM") {
      if (!Array.isArray(obj)) {
        return "{{ INVALID TEMPLATE TAG - operator ENUM is only applicable on an array }}";
      }
      return obj.join(", ");
    }
    return `{{ INVALID TEMPLATE TAG - unknown operator ${operator} }}`;
  }
  return "{{ INVALID TEMPLATE TAG }}";
}
function traverseMetaData(path, mediaTypeModel) {
  let o = mediaTypeModel;
  for (const part of path) {
    if (o !== void 0) {
      o = o[part];
    }
  }
  return o;
}
function markdownTable(content) {
  const rows = content.length;
  if (rows === 0) {
    return "";
  }
  const columns = content[0].length;
  if (columns === 0) {
    return "";
  }
  for (const row of content) {
    if (row.length !== columns) {
      return "";
    }
  }
  const longestStringInColumns = [];
  for (let i = 0; i < columns; i++) {
    let longestStringInColumn = 0;
    for (const row of content) {
      if (row[i].length > longestStringInColumn) {
        longestStringInColumn = row[i].length;
      }
    }
    longestStringInColumns.push(longestStringInColumn);
  }
  let table = "";
  for (let i = 0; i < rows; i++) {
    table += "|";
    for (let j = 0; j < columns; j++) {
      let element2 = content[i][j];
      element2 += " ".repeat(longestStringInColumns[j] - element2.length);
      table += " " + element2 + " |";
    }
    table += "\n";
    if (i === 0) {
      table += "|";
      for (let j = 0; j < columns; j++) {
        table += " " + "-".repeat(longestStringInColumns[j]) + " |";
      }
      table += "\n";
    }
  }
  return table;
}
function dateToString(date) {
  return `${date.getMonth() + 1}-${date.getDate()}-${date.getFullYear()}`;
}
function timeToString(time) {
  return `${time.getHours()}-${time.getMinutes()}-${time.getSeconds()}`;
}
function dateTimeToString(dateTime) {
  return `${dateToString(dateTime)} ${timeToString(dateTime)}`;
}
function mod(n, m) {
  return (n % m + m) % m;
}
function capitalizeFirstLetter(string) {
  return string.charAt(0).toUpperCase() + string.slice(1);
}
var PropertyMappingValidationError = class extends Error {
  constructor(message) {
    super(message);
  }
};
var PropertyMappingNameConflictError = class extends Error {
  constructor(message) {
    super(message);
  }
};
function migrateObject(object, oldData, defaultData) {
  for (const key in object) {
    object[key] = oldData.hasOwnProperty(key) ? oldData[key] : defaultData[key];
  }
}
function unCamelCase(str) {
  return str.replace(/([a-z])([A-Z])/g, "$1 $2").replace(/\b([A-Z]+)([A-Z])([a-z])/, "$1 $2$3").replace(/^./, function(str2) {
    return str2.toUpperCase();
  });
}

// src/settings/suggesters/Suggest.ts
var Suggest = class {
  constructor(owner, containerEl, scope) {
    this.owner = owner;
    this.containerEl = containerEl;
    containerEl.on("click", ".suggestion-item", this.onSuggestionClick.bind(this));
    containerEl.on("mousemove", ".suggestion-item", this.onSuggestionMouseover.bind(this));
    scope.register([], "ArrowUp", (event) => {
      if (!event.isComposing) {
        this.setSelectedItem(this.selectedItem - 1, true);
        return false;
      }
    });
    scope.register([], "ArrowDown", (event) => {
      if (!event.isComposing) {
        this.setSelectedItem(this.selectedItem + 1, true);
        return false;
      }
    });
    scope.register([], "Enter", (event) => {
      if (!event.isComposing) {
        this.useSelectedItem(event);
        return false;
      }
    });
  }
  onSuggestionClick(event, el) {
    event.preventDefault();
    const item = this.suggestions.indexOf(el);
    this.setSelectedItem(item, false);
    this.useSelectedItem(event);
  }
  onSuggestionMouseover(_event, el) {
    const item = this.suggestions.indexOf(el);
    this.setSelectedItem(item, false);
  }
  setSuggestions(values) {
    this.containerEl.empty();
    const suggestionEls = [];
    values.forEach((value) => {
      const suggestionEl = this.containerEl.createDiv("suggestion-item");
      this.owner.renderSuggestion(value, suggestionEl);
      suggestionEls.push(suggestionEl);
    });
    this.values = values;
    this.suggestions = suggestionEls;
    this.setSelectedItem(0, false);
  }
  useSelectedItem(event) {
    const currentValue = this.values[this.selectedItem];
    if (currentValue) {
      this.owner.selectSuggestion(currentValue, event);
    }
  }
  setSelectedItem(selectedIndex, scrollIntoView) {
    const normalizedIndex = this.suggestions.length > 0 ? wrapAround(selectedIndex, this.suggestions.length) : 0;
    const prevSelectedSuggestion = this.suggestions[this.selectedItem];
    const selectedSuggestion = this.suggestions[normalizedIndex];
    prevSelectedSuggestion == null ? void 0 : prevSelectedSuggestion.removeClass("is-selected");
    selectedSuggestion == null ? void 0 : selectedSuggestion.addClass("is-selected");
    this.selectedItem = normalizedIndex;
    if (scrollIntoView) {
      selectedSuggestion.scrollIntoView(false);
    }
  }
};
var TextInputSuggest = class {
  constructor(app, inputEl) {
    this.app = app;
    this.inputEl = inputEl;
    this.scope = new import_obsidian.Scope();
    this.suggestEl = createDiv("suggestion-container");
    const suggestion = this.suggestEl.createDiv("suggestion");
    this.suggest = new Suggest(this, suggestion, this.scope);
    this.scope.register([], "Escape", this.close.bind(this));
    this.inputEl.addEventListener("input", this.onInputChanged.bind(this));
    this.inputEl.addEventListener("focus", this.onInputChanged.bind(this));
    this.inputEl.addEventListener("blur", this.close.bind(this));
    this.suggestEl.on("mousedown", ".suggestion-container", (event) => {
      event.preventDefault();
    });
  }
  onInputChanged() {
    const inputStr = this.inputEl.value;
    const suggestions = this.getSuggestions(inputStr);
    if (suggestions.length > 0) {
      this.suggest.setSuggestions(suggestions);
      this.open(this.app.dom.appContainerEl, this.inputEl);
    }
  }
  open(container, inputEl) {
    this.app.keymap.pushScope(this.scope);
    container.appendChild(this.suggestEl);
    this.popper = createPopper(inputEl, this.suggestEl, {
      placement: "bottom-start",
      modifiers: [
        {
          name: "sameWidth",
          enabled: true,
          fn: ({ state, instance: instance4 }) => {
            const targetWidth = `${state.rects.reference.width}px`;
            if (state.styles.popper.width === targetWidth) {
              return;
            }
            state.styles.popper.width = targetWidth;
            instance4.update();
          },
          phase: "beforeWrite",
          requires: ["computeStyles"]
        }
      ]
    });
  }
  close() {
    this.app.keymap.popScope(this.scope);
    this.suggest.setSuggestions([]);
    this.popper.destroy();
    this.suggestEl.detach();
  }
};

// src/settings/suggesters/FolderSuggest.ts
var FolderSuggest = class extends TextInputSuggest {
  getSuggestions(inputStr) {
    const abstractFiles = this.app.vault.getAllLoadedFiles();
    const folders = [];
    const lowerCaseInputStr = inputStr.toLowerCase();
    abstractFiles.forEach((folder) => {
      if (folder instanceof import_obsidian2.TFolder && folder.path.toLowerCase().contains(lowerCaseInputStr)) {
        folders.push(folder);
      }
    });
    return folders;
  }
  renderSuggestion(file, el) {
    el.setText(file.path);
  }
  selectSuggestion(file) {
    this.inputEl.value = file.path;
    this.inputEl.trigger("input");
    this.close();
  }
};

// src/settings/suggesters/FileSuggest.ts
var import_obsidian3 = __toModule(require("obsidian"));
var FileSuggest = class extends TextInputSuggest {
  getSuggestions(inputStr) {
    const abstractFiles = this.app.vault.getAllLoadedFiles();
    const files = [];
    const lowerCaseInputStr = inputStr.toLowerCase();
    abstractFiles.forEach((file) => {
      if (file instanceof import_obsidian3.TFile && file.name.toLowerCase().contains(lowerCaseInputStr)) {
        files.push(file);
      }
    });
    return files;
  }
  renderSuggestion(file, el) {
    el.setText(file.name);
  }
  selectSuggestion(file) {
    this.inputEl.value = file.name;
    this.inputEl.trigger("input");
    this.close();
  }
};

// node_modules/svelte/internal/index.mjs
function noop() {
}
function run(fn2) {
  return fn2();
}
function blank_object() {
  return Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || (a && typeof a === "object" || typeof a === "function");
}
function is_empty(obj) {
  return Object.keys(obj).length === 0;
}
var tasks = new Set();
var globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : global;
var ResizeObserverSingleton = class {
  constructor(options) {
    this.options = options;
    this._listeners = "WeakMap" in globals ? new WeakMap() : void 0;
  }
  observe(element2, listener) {
    this._listeners.set(element2, listener);
    this._getObserver().observe(element2, this.options);
    return () => {
      this._listeners.delete(element2);
      this._observer.unobserve(element2);
    };
  }
  _getObserver() {
    var _a;
    return (_a = this._observer) !== null && _a !== void 0 ? _a : this._observer = new ResizeObserver((entries) => {
      var _a2;
      for (const entry of entries) {
        ResizeObserverSingleton.entries.set(entry.target, entry);
        (_a2 = this._listeners.get(entry.target)) === null || _a2 === void 0 ? void 0 : _a2(entry);
      }
    });
  }
};
ResizeObserverSingleton.entries = "WeakMap" in globals ? new WeakMap() : void 0;
var is_hydrating = false;
function start_hydrating() {
  is_hydrating = true;
}
function end_hydrating() {
  is_hydrating = false;
}
function append(target, node) {
  target.appendChild(node);
}
function append_styles(target, style_sheet_id, styles) {
  const append_styles_to = get_root_for_style(target);
  if (!append_styles_to.getElementById(style_sheet_id)) {
    const style = element("style");
    style.id = style_sheet_id;
    style.textContent = styles;
    append_stylesheet(append_styles_to, style);
  }
}
function get_root_for_style(node) {
  if (!node)
    return document;
  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
  if (root && root.host) {
    return root;
  }
  return node.ownerDocument;
}
function append_stylesheet(node, style) {
  append(node.head || node, style);
  return style.sheet;
}
function insert(target, node, anchor) {
  target.insertBefore(node, anchor || null);
}
function detach(node) {
  if (node.parentNode) {
    node.parentNode.removeChild(node);
  }
}
function destroy_each(iterations, detaching) {
  for (let i = 0; i < iterations.length; i += 1) {
    if (iterations[i])
      iterations[i].d(detaching);
  }
}
function element(name) {
  return document.createElement(name);
}
function text(data) {
  return document.createTextNode(data);
}
function space() {
  return text(" ");
}
function empty() {
  return text("");
}
function listen(node, event, handler, options) {
  node.addEventListener(event, handler, options);
  return () => node.removeEventListener(event, handler, options);
}
function attr(node, attribute, value) {
  if (value == null)
    node.removeAttribute(attribute);
  else if (node.getAttribute(attribute) !== value)
    node.setAttribute(attribute, value);
}
function children(element2) {
  return Array.from(element2.childNodes);
}
function set_data(text2, data) {
  data = "" + data;
  if (text2.data === data)
    return;
  text2.data = data;
}
function set_input_value(input, value) {
  input.value = value == null ? "" : value;
}
function set_style(node, key, value, important) {
  if (value == null) {
    node.style.removeProperty(key);
  } else {
    node.style.setProperty(key, value, important ? "important" : "");
  }
}
function select_option(select, value, mounting) {
  for (let i = 0; i < select.options.length; i += 1) {
    const option = select.options[i];
    if (option.__value === value) {
      option.selected = true;
      return;
    }
  }
  if (!mounting || value !== void 0) {
    select.selectedIndex = -1;
  }
}
function select_value(select) {
  const selected_option = select.querySelector(":checked");
  return selected_option && selected_option.__value;
}
var managed_styles = new Map();
var current_component;
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function onMount(fn2) {
  get_current_component().$$.on_mount.push(fn2);
}
var dirty_components = [];
var binding_callbacks = [];
var render_callbacks = [];
var flush_callbacks = [];
var resolved_promise = /* @__PURE__ */ Promise.resolve();
var update_scheduled = false;
function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}
function add_render_callback(fn2) {
  render_callbacks.push(fn2);
}
var seen_callbacks = new Set();
var flushidx = 0;
function flush() {
  if (flushidx !== 0) {
    return;
  }
  const saved_component = current_component;
  do {
    try {
      while (flushidx < dirty_components.length) {
        const component = dirty_components[flushidx];
        flushidx++;
        set_current_component(component);
        update(component.$$);
      }
    } catch (e) {
      dirty_components.length = 0;
      flushidx = 0;
      throw e;
    }
    set_current_component(null);
    dirty_components.length = 0;
    flushidx = 0;
    while (binding_callbacks.length)
      binding_callbacks.pop()();
    for (let i = 0; i < render_callbacks.length; i += 1) {
      const callback = render_callbacks[i];
      if (!seen_callbacks.has(callback)) {
        seen_callbacks.add(callback);
        callback();
      }
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }
  update_scheduled = false;
  seen_callbacks.clear();
  set_current_component(saved_component);
}
function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
    $$.after_update.forEach(add_render_callback);
  }
}
function flush_render_callbacks(fns) {
  const filtered = [];
  const targets = [];
  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));
  targets.forEach((c) => c());
  render_callbacks = filtered;
}
var outroing = new Set();
var outros;
function group_outros() {
  outros = {
    r: 0,
    c: [],
    p: outros
  };
}
function check_outros() {
  if (!outros.r) {
    run_all(outros.c);
  }
  outros = outros.p;
}
function transition_in(block, local) {
  if (block && block.i) {
    outroing.delete(block);
    block.i(local);
  }
}
function transition_out(block, local, detach2, callback) {
  if (block && block.o) {
    if (outroing.has(block))
      return;
    outroing.add(block);
    outros.c.push(() => {
      outroing.delete(block);
      if (callback) {
        if (detach2)
          block.d(1);
        callback();
      }
    });
    block.o(local);
  } else if (callback) {
    callback();
  }
}
var _boolean_attributes = [
  "allowfullscreen",
  "allowpaymentrequest",
  "async",
  "autofocus",
  "autoplay",
  "checked",
  "controls",
  "default",
  "defer",
  "disabled",
  "formnovalidate",
  "hidden",
  "inert",
  "ismap",
  "loop",
  "multiple",
  "muted",
  "nomodule",
  "novalidate",
  "open",
  "playsinline",
  "readonly",
  "required",
  "reversed",
  "selected"
];
var boolean_attributes = new Set([..._boolean_attributes]);
function create_component(block) {
  block && block.c();
}
function mount_component(component, target, anchor, customElement) {
  const { fragment, after_update } = component.$$;
  fragment && fragment.m(target, anchor);
  if (!customElement) {
    add_render_callback(() => {
      const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
      if (component.$$.on_destroy) {
        component.$$.on_destroy.push(...new_on_destroy);
      } else {
        run_all(new_on_destroy);
      }
      component.$$.on_mount = [];
    });
  }
  after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
  const $$ = component.$$;
  if ($$.fragment !== null) {
    flush_render_callbacks($$.after_update);
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching);
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
function make_dirty(component, i) {
  if (component.$$.dirty[0] === -1) {
    dirty_components.push(component);
    schedule_update();
    component.$$.dirty.fill(0);
  }
  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;
}
function init(component, options, instance4, create_fragment4, not_equal, props, append_styles2, dirty = [-1]) {
  const parent_component = current_component;
  set_current_component(component);
  const $$ = component.$$ = {
    fragment: null,
    ctx: [],
    props,
    update: noop,
    not_equal,
    bound: blank_object(),
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
    callbacks: blank_object(),
    dirty,
    skip_bound: false,
    root: options.target || parent_component.$$.root
  };
  append_styles2 && append_styles2($$.root);
  let ready = false;
  $$.ctx = instance4 ? instance4(component, options.props || {}, (i, ret, ...rest) => {
    const value = rest.length ? rest[0] : ret;
    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
      if (!$$.skip_bound && $$.bound[i])
        $$.bound[i](value);
      if (ready)
        make_dirty(component, i);
    }
    return ret;
  }) : [];
  $$.update();
  ready = true;
  run_all($$.before_update);
  $$.fragment = create_fragment4 ? create_fragment4($$.ctx) : false;
  if (options.target) {
    if (options.hydrate) {
      start_hydrating();
      const nodes = children(options.target);
      $$.fragment && $$.fragment.l(nodes);
      nodes.forEach(detach);
    } else {
      $$.fragment && $$.fragment.c();
    }
    if (options.intro)
      transition_in(component.$$.fragment);
    mount_component(component, options.target, options.anchor, options.customElement);
    end_hydrating();
    flush();
  }
  set_current_component(parent_component);
}
var SvelteElement;
if (typeof HTMLElement === "function") {
  SvelteElement = class extends HTMLElement {
    constructor() {
      super();
      this.attachShadow({ mode: "open" });
    }
    connectedCallback() {
      const { on_mount } = this.$$;
      this.$$.on_disconnect = on_mount.map(run).filter(is_function);
      for (const key in this.$$.slotted) {
        this.appendChild(this.$$.slotted[key]);
      }
    }
    attributeChangedCallback(attr2, _oldValue, newValue) {
      this[attr2] = newValue;
    }
    disconnectedCallback() {
      run_all(this.$$.on_disconnect);
    }
    $destroy() {
      destroy_component(this, 1);
      this.$destroy = noop;
    }
    $on(type, callback) {
      if (!is_function(callback)) {
        return noop;
      }
      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
      callbacks.push(callback);
      return () => {
        const index = callbacks.indexOf(callback);
        if (index !== -1)
          callbacks.splice(index, 1);
      };
    }
    $set($$props) {
      if (this.$$set && !is_empty($$props)) {
        this.$$.skip_bound = true;
        this.$$set($$props);
        this.$$.skip_bound = false;
      }
    }
  };
}
var SvelteComponent = class {
  $destroy() {
    destroy_component(this, 1);
    this.$destroy = noop;
  }
  $on(type, callback) {
    if (!is_function(callback)) {
      return noop;
    }
    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
    callbacks.push(callback);
    return () => {
      const index = callbacks.indexOf(callback);
      if (index !== -1)
        callbacks.splice(index, 1);
    };
  }
  $set($$props) {
    if (this.$$set && !is_empty($$props)) {
      this.$$.skip_bound = true;
      this.$$set($$props);
      this.$$.skip_bound = false;
    }
  }
};

// src/settings/PropertyMapping.ts
var PropertyMappingOption;
(function(PropertyMappingOption2) {
  PropertyMappingOption2["Default"] = "default";
  PropertyMappingOption2["Map"] = "remap";
  PropertyMappingOption2["Remove"] = "remove";
})(PropertyMappingOption || (PropertyMappingOption = {}));
var propertyMappingOptions = [PropertyMappingOption.Default, PropertyMappingOption.Map, PropertyMappingOption.Remove];
var PropertyMappingModel = class {
  constructor(type, properties) {
    this.type = type;
    this.properties = properties != null ? properties : [];
  }
  validate() {
    console.debug(`MDB | validated property mappings for ${this.type}`);
    for (const property of this.properties) {
      const propertyValidation = property.validate();
      if (!propertyValidation.res) {
        return {
          res: false,
          err: propertyValidation.err
        };
      }
    }
    for (const property of this.getMappedProperties()) {
      const propertiesWithSameTarget = this.getMappedProperties().filter((x) => x.newProperty === property.newProperty);
      if (propertiesWithSameTarget.length === 0) {
      } else if (propertiesWithSameTarget.length === 1) {
      } else {
        return {
          res: false,
          err: new PropertyMappingNameConflictError(`Multiple remapped properties (${propertiesWithSameTarget.map((x) => x.toString()).toString()}) may not share the same name.`)
        };
      }
    }
    for (const property of this.getMappedProperties()) {
      const propertiesWithSameTarget = this.properties.filter((x) => x.newProperty === property.property);
      if (propertiesWithSameTarget.length === 0) {
      } else {
        return {
          res: false,
          err: new PropertyMappingNameConflictError(`Remapped property (${property}) may not share it's new name with an existing property.`)
        };
      }
    }
    return {
      res: true
    };
  }
  getMappedProperties() {
    return this.properties.filter((x) => x.mapping === PropertyMappingOption.Map);
  }
  copy() {
    const copy = new PropertyMappingModel(this.type);
    for (const property of this.properties) {
      const propertyCopy = new PropertyMapping(property.property, property.newProperty, property.mapping, property.locked);
      copy.properties.push(propertyCopy);
    }
    return copy;
  }
};
var PropertyMapping = class {
  constructor(property, newProperty, mapping, locked) {
    this.property = property;
    this.newProperty = newProperty;
    this.mapping = mapping;
    this.locked = locked != null ? locked : false;
  }
  validate() {
    if (this.locked) {
      if (this.mapping === PropertyMappingOption.Remove) {
        return {
          res: false,
          err: new PropertyMappingValidationError(`Error in property mapping "${this.toString()}": locked property may not be removed.`)
        };
      }
      if (this.mapping === PropertyMappingOption.Map) {
        return {
          res: false,
          err: new PropertyMappingValidationError(`Error in property mapping "${this.toString()}": locked property may not be remapped.`)
        };
      }
    }
    if (this.mapping === PropertyMappingOption.Default) {
      return { res: true };
    }
    if (this.mapping === PropertyMappingOption.Remove) {
      return { res: true };
    }
    if (!this.property || !containsOnlyLettersAndUnderscores(this.property)) {
      return {
        res: false,
        err: new PropertyMappingValidationError(`Error in property mapping "${this.toString()}": property may not be empty and only contain letters and underscores.`)
      };
    }
    if (!this.newProperty || !containsOnlyLettersAndUnderscores(this.newProperty)) {
      return {
        res: false,
        err: new PropertyMappingValidationError(`Error in property mapping "${this.toString()}": new property may not be empty and only contain letters and underscores.`)
      };
    }
    return {
      res: true
    };
  }
  toString() {
    if (this.mapping === PropertyMappingOption.Default) {
      return this.property;
    } else if (this.mapping === PropertyMappingOption.Map) {
      return `${this.property} -> ${this.newProperty}`;
    } else if (this.mapping === PropertyMappingOption.Remove) {
      return `remove ${this.property}`;
    }
    return this.property;
  }
};

// src/settings/Icon.svelte
var import_obsidian4 = __toModule(require("obsidian"));
function add_css(target) {
  append_styles(target, "svelte-klmgqw", ".icon-wrapper.svelte-klmgqw{display:inline-block;position:relative;width:20px}.icon.svelte-klmgqw{position:absolute;height:20px;width:20px;top:calc(50% - 10px)}");
}
function create_if_block(ctx) {
  let div1;
  let div0;
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      attr(div0, "class", "icon svelte-klmgqw");
      attr(div1, "class", "icon-wrapper svelte-klmgqw");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      ctx[3](div0);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(div1);
      ctx[3](null);
    }
  };
}
function create_fragment(ctx) {
  let if_block_anchor;
  let if_block = ctx[0].length > 0 && create_if_block(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (ctx2[0].length > 0) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance($$self, $$props, $$invalidate) {
  let { iconName = "" } = $$props;
  let { iconSize = 20 } = $$props;
  let iconEl;
  onMount(() => {
    (0, import_obsidian4.setIcon)(iconEl, iconName, iconSize);
  });
  function div0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      iconEl = $$value;
      $$invalidate(1, iconEl);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("iconName" in $$props2)
      $$invalidate(0, iconName = $$props2.iconName);
    if ("iconSize" in $$props2)
      $$invalidate(2, iconSize = $$props2.iconSize);
  };
  return [iconName, iconEl, iconSize, div0_binding];
}
var Icon = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance, create_fragment, safe_not_equal, { iconName: 0, iconSize: 2 }, add_css);
  }
};
var Icon_default = Icon;

// src/settings/PropertyMappingModelComponent.svelte
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[7] = list[i];
  child_ctx[8] = list;
  child_ctx[9] = i;
  return child_ctx;
}
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[10] = list[i];
  return child_ctx;
}
function create_else_block(ctx) {
  let select;
  let t;
  let if_block_anchor;
  let current;
  let mounted;
  let dispose;
  let each_value_1 = propertyMappingOptions;
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
  }
  function select_change_handler() {
    ctx[3].call(select, ctx[8], ctx[9]);
  }
  let if_block = ctx[7].mapping === PropertyMappingOption.Map && create_if_block_2(ctx);
  return {
    c() {
      select = element("select");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      attr(select, "class", "dropdown");
      if (ctx[7].mapping === void 0)
        add_render_callback(select_change_handler);
    },
    m(target, anchor) {
      insert(target, select, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(select, null);
        }
      }
      select_option(select, ctx[7].mapping, true);
      insert(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = listen(select, "change", select_change_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 0) {
        each_value_1 = propertyMappingOptions;
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1(ctx, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_1(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(select, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_1.length;
      }
      if (dirty & 1) {
        select_option(select, ctx[7].mapping);
      }
      if (ctx[7].mapping === PropertyMappingOption.Map) {
        if (if_block) {
          if_block.p(ctx, dirty);
          if (dirty & 1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_2(ctx);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(select);
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(t);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_1(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = "property can not be remapped";
      attr(div, "class", "media-db-plugin-property-binding-text");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_each_block_1(ctx) {
  let option;
  let t0_value = ctx[10] + "";
  let t0;
  let t1;
  let option_value_value;
  return {
    c() {
      option = element("option");
      t0 = text(t0_value);
      t1 = space();
      option.__value = option_value_value = ctx[10];
      option.value = option.__value;
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t0);
      append(option, t1);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(option);
    }
  };
}
function create_if_block_2(ctx) {
  let icon;
  let t;
  let div;
  let input;
  let current;
  let mounted;
  let dispose;
  icon = new Icon_default({ props: { iconName: "arrow-right" } });
  function input_input_handler() {
    ctx[4].call(input, ctx[8], ctx[9]);
  }
  return {
    c() {
      create_component(icon.$$.fragment);
      t = space();
      div = element("div");
      input = element("input");
      attr(input, "type", "text");
      attr(input, "spellcheck", "false");
      attr(div, "class", "media-db-plugin-property-mapping-to");
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      insert(target, t, anchor);
      insert(target, div, anchor);
      append(div, input);
      set_input_value(input, ctx[7].newProperty);
      current = true;
      if (!mounted) {
        dispose = listen(input, "input", input_input_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 1 && input.value !== ctx[7].newProperty) {
        set_input_value(input, ctx[7].newProperty);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
      if (detaching)
        detach(t);
      if (detaching)
        detach(div);
      mounted = false;
      dispose();
    }
  };
}
function create_each_block(ctx) {
  let div1;
  let div0;
  let pre;
  let code;
  let t0_value = ctx[7].property + "";
  let t0;
  let t1;
  let current_block_type_index;
  let if_block;
  let t2;
  let current;
  const if_block_creators = [create_if_block_1, create_else_block];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[7].locked)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      pre = element("pre");
      code = element("code");
      t0 = text(t0_value);
      t1 = space();
      if_block.c();
      t2 = space();
      attr(pre, "class", "media-db-plugin-property-mapping-element-property-name");
      attr(div0, "class", "media-db-plugin-property-mapping-element-property-name-wrapper");
      attr(div1, "class", "media-db-plugin-property-mapping-element");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div0, pre);
      append(pre, code);
      append(code, t0);
      append(div1, t1);
      if_blocks[current_block_type_index].m(div1, null);
      append(div1, t2);
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty & 1) && t0_value !== (t0_value = ctx2[7].property + ""))
        set_data(t0, t0_value);
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div1, t2);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      if_blocks[current_block_type_index].d();
    }
  };
}
function create_if_block2(ctx) {
  var _a, _b;
  let div;
  let t_value = ((_b = (_a = ctx[2]) == null ? void 0 : _a.err) == null ? void 0 : _b.message) + "";
  let t;
  return {
    c() {
      div = element("div");
      t = text(t_value);
      attr(div, "class", "media-db-plugin-property-mapping-validation");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t);
    },
    p(ctx2, dirty) {
      var _a2, _b2;
      if (dirty & 4 && t_value !== (t_value = ((_b2 = (_a2 = ctx2[2]) == null ? void 0 : _a2.err) == null ? void 0 : _b2.message) + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_fragment2(ctx) {
  var _a;
  let div2;
  let div0;
  let t0_value = capitalizeFirstLetter(ctx[0].type) + "";
  let t0;
  let t1;
  let div1;
  let t2;
  let t3;
  let button;
  let t4;
  let button_class_value;
  let current;
  let mounted;
  let dispose;
  let each_value = ctx[0].properties;
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  let if_block = !((_a = ctx[2]) == null ? void 0 : _a.res) && create_if_block2(ctx);
  return {
    c() {
      var _a2;
      div2 = element("div");
      div0 = element("div");
      t0 = text(t0_value);
      t1 = space();
      div1 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t2 = space();
      if (if_block)
        if_block.c();
      t3 = space();
      button = element("button");
      t4 = text("Save");
      attr(div0, "class", "setting-item-name");
      attr(div1, "class", "media-db-plugin-property-mappings-container");
      attr(button, "class", button_class_value = "media-db-plugin-property-mappings-save-button " + (((_a2 = ctx[2]) == null ? void 0 : _a2.res) ? "mod-cta" : "mod-muted"));
      attr(div2, "class", "media-db-plugin-property-mappings-model-container");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      append(div0, t0);
      append(div2, t1);
      append(div2, div1);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div1, null);
        }
      }
      append(div2, t2);
      if (if_block)
        if_block.m(div2, null);
      append(div2, t3);
      append(div2, button);
      append(button, t4);
      current = true;
      if (!mounted) {
        dispose = listen(button, "click", ctx[5]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      var _a2, _b;
      if ((!current || dirty & 1) && t0_value !== (t0_value = capitalizeFirstLetter(ctx2[0].type) + ""))
        set_data(t0, t0_value);
      if (dirty & 1) {
        each_value = ctx2[0].properties;
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div1, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      if (!((_a2 = ctx2[2]) == null ? void 0 : _a2.res)) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block2(ctx2);
          if_block.c();
          if_block.m(div2, t3);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (!current || dirty & 4 && button_class_value !== (button_class_value = "media-db-plugin-property-mappings-save-button " + (((_b = ctx2[2]) == null ? void 0 : _b.res) ? "mod-cta" : "mod-muted"))) {
        attr(button, "class", button_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      destroy_each(each_blocks, detaching);
      if (if_block)
        if_block.d();
      mounted = false;
      dispose();
    }
  };
}
function instance2($$self, $$props, $$invalidate) {
  let { model } = $$props;
  let { save } = $$props;
  let validationResult;
  function modelChanged(model2) {
    $$invalidate(2, validationResult = model2.validate());
  }
  function select_change_handler(each_value, property_index) {
    each_value[property_index].mapping = select_value(this);
    $$invalidate(0, model);
  }
  function input_input_handler(each_value, property_index) {
    each_value[property_index].newProperty = this.value;
    $$invalidate(0, model);
  }
  const click_handler = () => {
    if (model.validate().res)
      save(model);
  };
  $$self.$$set = ($$props2) => {
    if ("model" in $$props2)
      $$invalidate(0, model = $$props2.model);
    if ("save" in $$props2)
      $$invalidate(1, save = $$props2.save);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      $:
        modelChanged(model);
    }
  };
  return [
    model,
    save,
    validationResult,
    select_change_handler,
    input_input_handler,
    click_handler
  ];
}
var PropertyMappingModelComponent = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance2, create_fragment2, safe_not_equal, { model: 0, save: 1 });
  }
};
var PropertyMappingModelComponent_default = PropertyMappingModelComponent;

// src/settings/PropertyMappingModelsComponent.svelte
function get_each_context2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[2] = list[i];
  return child_ctx;
}
function create_each_block2(ctx) {
  let propertymappingmodelcomponent;
  let current;
  propertymappingmodelcomponent = new PropertyMappingModelComponent_default({
    props: {
      model: ctx[2],
      save: ctx[1]
    }
  });
  return {
    c() {
      create_component(propertymappingmodelcomponent.$$.fragment);
    },
    m(target, anchor) {
      mount_component(propertymappingmodelcomponent, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const propertymappingmodelcomponent_changes = {};
      if (dirty & 1)
        propertymappingmodelcomponent_changes.model = ctx2[2];
      if (dirty & 2)
        propertymappingmodelcomponent_changes.save = ctx2[1];
      propertymappingmodelcomponent.$set(propertymappingmodelcomponent_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(propertymappingmodelcomponent.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(propertymappingmodelcomponent.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(propertymappingmodelcomponent, detaching);
    }
  };
}
function create_fragment3(ctx) {
  let div;
  let current;
  let each_value = ctx[0];
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block2(get_each_context2(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div, "class", "setting-item");
      set_style(div, "display", "flex");
      set_style(div, "gap", "10px");
      set_style(div, "flex-direction", "column");
      set_style(div, "align-items", "stretch");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & 3) {
        each_value = ctx2[0];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context2(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block2(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_each(each_blocks, detaching);
    }
  };
}
function instance3($$self, $$props, $$invalidate) {
  let { models = [] } = $$props;
  let { save } = $$props;
  $$self.$$set = ($$props2) => {
    if ("models" in $$props2)
      $$invalidate(0, models = $$props2.models);
    if ("save" in $$props2)
      $$invalidate(1, save = $$props2.save);
  };
  return [models, save];
}
var PropertyMappingModelsComponent = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance3, create_fragment3, safe_not_equal, { models: 0, save: 1 });
  }
};
var PropertyMappingModelsComponent_default = PropertyMappingModelsComponent;

// src/utils/MediaType.ts
var MediaType;
(function(MediaType2) {
  MediaType2["Movie"] = "movie";
  MediaType2["Series"] = "series";
  MediaType2["Game"] = "game";
  MediaType2["MusicRelease"] = "musicRelease";
  MediaType2["Wiki"] = "wiki";
  MediaType2["BoardGame"] = "boardgame";
})(MediaType || (MediaType = {}));

// src/utils/MediaTypeManager.ts
var import_obsidian5 = __toModule(require("obsidian"));

// src/models/MediaTypeModel.ts
var MediaTypeModel = class {
  constructor() {
    this.type = void 0;
    this.subType = void 0;
    this.title = void 0;
    this.englishTitle = void 0;
    this.year = void 0;
    this.dataSource = void 0;
    this.url = void 0;
    this.id = void 0;
    this.userData = {};
  }
  toMetaDataObject() {
    return __spreadProps(__spreadValues(__spreadValues({}, this.getWithOutUserData()), this.userData), { tags: this.getTags().join("/") });
  }
  getWithOutUserData() {
    const copy = Object.assign({}, this);
    delete copy.userData;
    return copy;
  }
};

// src/models/MovieModel.ts
var MovieModel = class extends MediaTypeModel {
  constructor(obj = {}) {
    super();
    this.genres = void 0;
    this.producer = void 0;
    this.duration = void 0;
    this.onlineRating = void 0;
    this.actors = void 0;
    this.image = void 0;
    this.released = void 0;
    this.streamingServices = void 0;
    this.premiere = void 0;
    this.userData = {
      watched: void 0,
      lastWatched: void 0,
      personalRating: void 0
    };
    migrateObject(this, obj, this);
    if (!obj.hasOwnProperty("userData")) {
      migrateObject(this.userData, obj, this.userData);
    }
    this.type = this.getMediaType();
  }
  getTags() {
    return [mediaDbTag, "tv", "movie"];
  }
  getMediaType() {
    return MediaType.Movie;
  }
  getSummary() {
    return this.englishTitle + " (" + this.year + ")";
  }
};

// src/models/SeriesModel.ts
var SeriesModel = class extends MediaTypeModel {
  constructor(obj = {}) {
    super();
    this.genres = void 0;
    this.studios = void 0;
    this.episodes = void 0;
    this.duration = void 0;
    this.onlineRating = void 0;
    this.actors = void 0;
    this.image = void 0;
    this.released = void 0;
    this.streamingServices = void 0;
    this.airing = void 0;
    this.airedFrom = void 0;
    this.airedTo = void 0;
    this.userData = {
      watched: void 0,
      lastWatched: void 0,
      personalRating: void 0
    };
    migrateObject(this, obj, this);
    if (!obj.hasOwnProperty("userData")) {
      migrateObject(this.userData, obj, this.userData);
    }
    this.type = this.getMediaType();
  }
  getTags() {
    return [mediaDbTag, "tv", "series"];
  }
  getMediaType() {
    return MediaType.Series;
  }
  getSummary() {
    return this.title + " (" + this.year + ")";
  }
};

// src/models/GameModel.ts
var GameModel = class extends MediaTypeModel {
  constructor(obj = {}) {
    super();
    this.genres = void 0;
    this.onlineRating = void 0;
    this.image = void 0;
    this.released = void 0;
    this.releaseDate = void 0;
    this.userData = {
      played: void 0,
      personalRating: void 0
    };
    migrateObject(this, obj, this);
    if (!obj.hasOwnProperty("userData")) {
      migrateObject(this.userData, obj, this.userData);
    }
    this.type = this.getMediaType();
  }
  getTags() {
    return [mediaDbTag, "game"];
  }
  getMediaType() {
    return MediaType.Game;
  }
  getSummary() {
    return this.englishTitle + " (" + this.year + ")";
  }
};

// src/models/WikiModel.ts
var WikiModel = class extends MediaTypeModel {
  constructor(obj = {}) {
    super();
    this.wikiUrl = void 0;
    this.lastUpdated = void 0;
    this.length = void 0;
    this.article = void 0;
    this.userData = {};
    migrateObject(this, obj, this);
    if (!obj.hasOwnProperty("userData")) {
      migrateObject(this.userData, obj, this.userData);
    }
    this.type = this.getMediaType();
  }
  getTags() {
    return [mediaDbTag, "wiki"];
  }
  getMediaType() {
    return MediaType.Wiki;
  }
  getWithOutUserData() {
    const copy = Object.assign({}, this);
    delete copy.userData;
    delete copy.article;
    return copy;
  }
  getSummary() {
    return this.title;
  }
};

// src/models/MusicReleaseModel.ts
var MusicReleaseModel = class extends MediaTypeModel {
  constructor(obj = {}) {
    super();
    this.genres = void 0;
    this.artists = void 0;
    this.rating = void 0;
    this.userData = {
      personalRating: void 0
    };
    migrateObject(this, obj, this);
    if (!obj.hasOwnProperty("userData")) {
      migrateObject(this.userData, obj, this.userData);
    }
    this.type = this.getMediaType();
  }
  getTags() {
    return [mediaDbTag, "music", this.subType];
  }
  getMediaType() {
    return MediaType.MusicRelease;
  }
  getSummary() {
    let summary = this.title + " (" + this.year + ")";
    if (this.artists.length > 0)
      summary += " - " + this.artists.join(", ");
    return summary;
  }
};

// src/models/BoardGameModel.ts
var BoardGameModel = class extends MediaTypeModel {
  constructor(obj = {}) {
    super();
    this.genres = void 0;
    this.onlineRating = void 0;
    this.minPlayers = void 0;
    this.maxPlayers = void 0;
    this.playtime = void 0;
    this.publishers = void 0;
    this.complexityRating = void 0;
    this.image = void 0;
    this.released = void 0;
    this.userData = {
      played: void 0,
      personalRating: void 0
    };
    migrateObject(this, obj, this);
    if (!obj.hasOwnProperty("userData")) {
      migrateObject(this.userData, obj, this.userData);
    }
    this.type = this.getMediaType();
  }
  getTags() {
    return [mediaDbTag, "boardgame"];
  }
  getMediaType() {
    return MediaType.BoardGame;
  }
  getSummary() {
    return this.englishTitle + " (" + this.year + ")";
  }
};

// src/utils/MediaTypeManager.ts
var MEDIA_TYPES = [MediaType.Movie, MediaType.Series, MediaType.Game, MediaType.Wiki, MediaType.MusicRelease, MediaType.BoardGame];
var MediaTypeManager = class {
  constructor() {
  }
  updateTemplates(settings) {
    this.mediaFileNameTemplateMap = new Map();
    this.mediaFileNameTemplateMap.set(MediaType.Movie, settings.movieFileNameTemplate);
    this.mediaFileNameTemplateMap.set(MediaType.Series, settings.seriesFileNameTemplate);
    this.mediaFileNameTemplateMap.set(MediaType.Game, settings.gameFileNameTemplate);
    this.mediaFileNameTemplateMap.set(MediaType.Wiki, settings.wikiFileNameTemplate);
    this.mediaFileNameTemplateMap.set(MediaType.MusicRelease, settings.musicReleaseFileNameTemplate);
    this.mediaFileNameTemplateMap.set(MediaType.BoardGame, settings.boardgameFileNameTemplate);
    this.mediaTemplateMap = new Map();
    this.mediaTemplateMap.set(MediaType.Movie, settings.movieTemplate);
    this.mediaTemplateMap.set(MediaType.Series, settings.seriesTemplate);
    this.mediaTemplateMap.set(MediaType.Game, settings.gameTemplate);
    this.mediaTemplateMap.set(MediaType.Wiki, settings.wikiTemplate);
    this.mediaTemplateMap.set(MediaType.MusicRelease, settings.musicReleaseTemplate);
    this.mediaTemplateMap.set(MediaType.BoardGame, settings.boardgameTemplate);
  }
  updateFolders(settings) {
    this.mediaFolderMap = new Map();
    this.mediaFolderMap.set(MediaType.Movie, settings.movieFolder);
    this.mediaFolderMap.set(MediaType.Series, settings.seriesFolder);
    this.mediaFolderMap.set(MediaType.Game, settings.gameFolder);
    this.mediaFolderMap.set(MediaType.Wiki, settings.wikiFolder);
    this.mediaFolderMap.set(MediaType.MusicRelease, settings.musicReleaseFolder);
    this.mediaFolderMap.set(MediaType.BoardGame, settings.boardgameFolder);
  }
  getFileName(mediaTypeModel) {
    return replaceTags(this.mediaFileNameTemplateMap.get(mediaTypeModel.getMediaType()), mediaTypeModel);
  }
  getTemplate(mediaTypeModel, app) {
    return __async(this, null, function* () {
      const templateFileName = this.mediaTemplateMap.get(mediaTypeModel.getMediaType());
      if (!templateFileName) {
        return "";
      }
      const templateFile = app.vault.getFiles().filter((f) => f.name === templateFileName).first();
      if (!templateFile) {
        return "";
      }
      const template = yield app.vault.cachedRead(templateFile);
      return replaceTags(template, mediaTypeModel);
    });
  }
  getFolder(mediaTypeModel, app) {
    return __async(this, null, function* () {
      let folderPath = this.mediaFolderMap.get(mediaTypeModel.getMediaType());
      if (!folderPath) {
        folderPath = `/`;
      }
      if (!(yield app.vault.adapter.exists(folderPath))) {
        yield app.vault.createFolder(folderPath);
      }
      const folder = app.vault.getAbstractFileByPath(folderPath);
      if (!(folder instanceof import_obsidian5.TFolder)) {
        throw Error(`Expected ${folder} to be instance of TFolder`);
      }
      return folder;
    });
  }
  createMediaTypeModelFromMediaType(obj, mediaType) {
    if (mediaType === MediaType.Movie) {
      return new MovieModel(obj);
    } else if (mediaType === MediaType.Series) {
      return new SeriesModel(obj);
    } else if (mediaType === MediaType.Game) {
      return new GameModel(obj);
    } else if (mediaType === MediaType.Wiki) {
      return new WikiModel(obj);
    } else if (mediaType === MediaType.MusicRelease) {
      return new MusicReleaseModel(obj);
    } else if (mediaType === MediaType.BoardGame) {
      return new BoardGameModel(obj);
    }
    return void 0;
  }
};

// src/settings/Settings.ts
var DEFAULT_SETTINGS = {
  OMDbKey: "",
  sfwFilter: true,
  useCustomYamlStringifier: true,
  templates: true,
  movieTemplate: "",
  seriesTemplate: "",
  gameTemplate: "",
  wikiTemplate: "",
  musicReleaseTemplate: "",
  boardgameTemplate: "",
  movieFileNameTemplate: "{{ title }} ({{ year }})",
  seriesFileNameTemplate: "{{ title }} ({{ year }})",
  gameFileNameTemplate: "{{ title }} ({{ year }})",
  wikiFileNameTemplate: "{{ title }}",
  musicReleaseFileNameTemplate: "{{ title }} (by {{ ENUM:artists }} - {{ year }})",
  boardgameFileNameTemplate: "{{ title }} ({{ year }})",
  moviePropertyConversionRules: "",
  seriesPropertyConversionRules: "",
  gamePropertyConversionRules: "",
  wikiPropertyConversionRules: "",
  musicReleasePropertyConversionRules: "",
  boardgamePropertyConversionRules: "",
  movieFolder: "Media DB/movies",
  seriesFolder: "Media DB/series",
  gameFolder: "Media DB/games",
  wikiFolder: "Media DB/wiki",
  musicReleaseFolder: "Media DB/music",
  boardgameFolder: "Media DB/boardgames",
  propertyMappingModels: []
};
var lockedPropertyMappings = ["type", "id", "dataSource"];
function getDefaultSettings(plugin) {
  const defaultSettings = DEFAULT_SETTINGS;
  const propertyMappingModels = [];
  for (const mediaType of MEDIA_TYPES) {
    const model = plugin.mediaTypeManager.createMediaTypeModelFromMediaType({}, mediaType);
    const metadataObj = model.toMetaDataObject();
    const propertyMappingModel = new PropertyMappingModel(mediaType);
    for (const key of Object.keys(metadataObj)) {
      propertyMappingModel.properties.push(new PropertyMapping(key, "", PropertyMappingOption.Default, lockedPropertyMappings.contains(key)));
    }
    propertyMappingModels.push(propertyMappingModel);
  }
  defaultSettings.propertyMappingModels = propertyMappingModels;
  return defaultSettings;
}
var MediaDbSettingTab = class extends import_obsidian6.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Media DB Plugin Settings" });
    new import_obsidian6.Setting(containerEl).setName("OMDb API key").setDesc('API key for "www.omdbapi.com".').addText((cb) => {
      cb.setPlaceholder("API key").setValue(this.plugin.settings.OMDbKey).onChange((data) => {
        this.plugin.settings.OMDbKey = data;
        this.plugin.saveSettings();
      });
    });
    new import_obsidian6.Setting(containerEl).setName("SFW filter").setDesc("Only shows SFW results for APIs that offer filtering.").addToggle((cb) => {
      cb.setValue(this.plugin.settings.sfwFilter).onChange((data) => {
        this.plugin.settings.sfwFilter = data;
        this.plugin.saveSettings();
      });
    });
    new import_obsidian6.Setting(containerEl).setName("YAML formatter").setDesc("Add optional quotation marks around strings in the metadata block.").addToggle((cb) => {
      cb.setValue(this.plugin.settings.useCustomYamlStringifier).onChange((data) => {
        this.plugin.settings.useCustomYamlStringifier = data;
        this.plugin.saveSettings();
      });
    });
    new import_obsidian6.Setting(containerEl).setName("Resolve {{ tags }} in templates").setDesc("Whether to resolve {{ tags }} in templates. The spaces inside the curly braces are important.").addToggle((cb) => {
      cb.setValue(this.plugin.settings.templates).onChange((data) => {
        this.plugin.settings.templates = data;
        this.plugin.saveSettings();
      });
    });
    containerEl.createEl("h3", { text: "New File Location" });
    new import_obsidian6.Setting(containerEl).setName("Movie Folder").setDesc("Where newly imported movies should be places.").addSearch((cb) => {
      new FolderSuggest(this.app, cb.inputEl);
      cb.setPlaceholder(DEFAULT_SETTINGS.movieFolder).setValue(this.plugin.settings.movieFolder).onChange((data) => {
        this.plugin.settings.movieFolder = data;
        this.plugin.saveSettings();
      });
    });
    new import_obsidian6.Setting(containerEl).setName("Series Folder").setDesc("Where newly imported series should be places.").addSearch((cb) => {
      new FolderSuggest(this.app, cb.inputEl);
      cb.setPlaceholder(DEFAULT_SETTINGS.seriesFolder).setValue(this.plugin.settings.seriesFolder).onChange((data) => {
        this.plugin.settings.seriesFolder = data;
        this.plugin.saveSettings();
      });
    });
    new import_obsidian6.Setting(containerEl).setName("Game Folder").setDesc("Where newly imported games should be places.").addSearch((cb) => {
      new FolderSuggest(this.app, cb.inputEl);
      cb.setPlaceholder(DEFAULT_SETTINGS.gameFolder).setValue(this.plugin.settings.gameFolder).onChange((data) => {
        this.plugin.settings.gameFolder = data;
        this.plugin.saveSettings();
      });
    });
    new import_obsidian6.Setting(containerEl).setName("Wiki Folder").setDesc("Where newly imported wiki articles should be places.").addSearch((cb) => {
      new FolderSuggest(this.app, cb.inputEl);
      cb.setPlaceholder(DEFAULT_SETTINGS.wikiFolder).setValue(this.plugin.settings.wikiFolder).onChange((data) => {
        this.plugin.settings.wikiFolder = data;
        this.plugin.saveSettings();
      });
    });
    new import_obsidian6.Setting(containerEl).setName("Music Folder").setDesc("Where newly imported music should be places.").addSearch((cb) => {
      new FolderSuggest(this.app, cb.inputEl);
      cb.setPlaceholder(DEFAULT_SETTINGS.musicReleaseFolder).setValue(this.plugin.settings.musicReleaseFolder).onChange((data) => {
        this.plugin.settings.musicReleaseFolder = data;
        this.plugin.saveSettings();
      });
    });
    new import_obsidian6.Setting(containerEl).setName("Board Game Folder").setDesc("Where newly imported board games should be places.").addSearch((cb) => {
      new FileSuggest(this.app, cb.inputEl);
      cb.setPlaceholder(DEFAULT_SETTINGS.boardgameFolder).setValue(this.plugin.settings.boardgameFolder).onChange((data) => {
        this.plugin.settings.boardgameFolder = data;
        this.plugin.saveSettings();
      });
    });
    containerEl.createEl("h3", { text: "Template Settings" });
    new import_obsidian6.Setting(containerEl).setName("Movie template").setDesc("Template file to be used when creating a new note for a movie.").addSearch((cb) => {
      new FileSuggest(this.app, cb.inputEl);
      cb.setPlaceholder("Example: movieTemplate.md").setValue(this.plugin.settings.movieTemplate).onChange((data) => {
        this.plugin.settings.movieTemplate = data;
        this.plugin.saveSettings();
      });
    });
    new import_obsidian6.Setting(containerEl).setName("Series template").setDesc("Template file to be used when creating a new note for a series.").addSearch((cb) => {
      new FileSuggest(this.app, cb.inputEl);
      cb.setPlaceholder("Example: seriesTemplate.md").setValue(this.plugin.settings.seriesTemplate).onChange((data) => {
        this.plugin.settings.seriesTemplate = data;
        this.plugin.saveSettings();
      });
    });
    new import_obsidian6.Setting(containerEl).setName("Game template").setDesc("Template file to be used when creating a new note for a game.").addSearch((cb) => {
      new FileSuggest(this.app, cb.inputEl);
      cb.setPlaceholder("Example: gameTemplate.md").setValue(this.plugin.settings.gameTemplate).onChange((data) => {
        this.plugin.settings.gameTemplate = data;
        this.plugin.saveSettings();
      });
    });
    new import_obsidian6.Setting(containerEl).setName("Wiki template").setDesc("Template file to be used when creating a new note for a wiki entry.").addSearch((cb) => {
      new FileSuggest(this.app, cb.inputEl);
      cb.setPlaceholder("Example: wikiTemplate.md").setValue(this.plugin.settings.wikiTemplate).onChange((data) => {
        this.plugin.settings.wikiTemplate = data;
        this.plugin.saveSettings();
      });
    });
    new import_obsidian6.Setting(containerEl).setName("Music Release template").setDesc("Template file to be used when creating a new note for a music release.").addSearch((cb) => {
      new FileSuggest(this.app, cb.inputEl);
      cb.setPlaceholder("Example: musicReleaseTemplate.md").setValue(this.plugin.settings.musicReleaseTemplate).onChange((data) => {
        this.plugin.settings.musicReleaseTemplate = data;
        this.plugin.saveSettings();
      });
    });
    new import_obsidian6.Setting(containerEl).setName("Board Game template").setDesc("Template file to be used when creating a new note for a boardgame.").addSearch((cb) => {
      new FileSuggest(this.app, cb.inputEl);
      cb.setPlaceholder("Example: boardgameTemplate.md").setValue(this.plugin.settings.boardgameTemplate).onChange((data) => {
        this.plugin.settings.boardgameTemplate = data;
        this.plugin.saveSettings();
      });
    });
    containerEl.createEl("h3", { text: "File Name Settings" });
    new import_obsidian6.Setting(containerEl).setName("Movie file name template").setDesc("Template for the file name used when creating a new note for a movie.").addText((cb) => {
      cb.setPlaceholder(`Example: ${DEFAULT_SETTINGS.movieFileNameTemplate}`).setValue(this.plugin.settings.movieFileNameTemplate).onChange((data) => {
        this.plugin.settings.movieFileNameTemplate = data;
        this.plugin.saveSettings();
      });
    });
    new import_obsidian6.Setting(containerEl).setName("Series file name template").setDesc("Template for the file name used when creating a new note for a series.").addText((cb) => {
      cb.setPlaceholder(`Example: ${DEFAULT_SETTINGS.seriesFileNameTemplate}`).setValue(this.plugin.settings.seriesFileNameTemplate).onChange((data) => {
        this.plugin.settings.seriesFileNameTemplate = data;
        this.plugin.saveSettings();
      });
    });
    new import_obsidian6.Setting(containerEl).setName("Game file name template").setDesc("Template for the file name used when creating a new note for a game.").addText((cb) => {
      cb.setPlaceholder(`Example: ${DEFAULT_SETTINGS.gameFileNameTemplate}`).setValue(this.plugin.settings.gameFileNameTemplate).onChange((data) => {
        this.plugin.settings.gameFileNameTemplate = data;
        this.plugin.saveSettings();
      });
    });
    new import_obsidian6.Setting(containerEl).setName("Wiki file name template").setDesc("Template for the file name used when creating a new note for a wiki entry.").addText((cb) => {
      cb.setPlaceholder(`Example: ${DEFAULT_SETTINGS.wikiFileNameTemplate}`).setValue(this.plugin.settings.wikiFileNameTemplate).onChange((data) => {
        this.plugin.settings.wikiFileNameTemplate = data;
        this.plugin.saveSettings();
      });
    });
    new import_obsidian6.Setting(containerEl).setName("Music Release file name template").setDesc("Template for the file name used when creating a new note for a music release.").addText((cb) => {
      cb.setPlaceholder(`Example: ${DEFAULT_SETTINGS.musicReleaseFileNameTemplate}`).setValue(this.plugin.settings.musicReleaseFileNameTemplate).onChange((data) => {
        this.plugin.settings.musicReleaseFileNameTemplate = data;
        this.plugin.saveSettings();
      });
    });
    new import_obsidian6.Setting(containerEl).setName("Board Game file name template").setDesc("Template for the file name used when creating a new note for a boardgame.").addText((cb) => {
      cb.setPlaceholder(`Example: ${DEFAULT_SETTINGS.boardgameFileNameTemplate}`).setValue(this.plugin.settings.boardgameFileNameTemplate).onChange((data) => {
        this.plugin.settings.boardgameFileNameTemplate = data;
        this.plugin.saveSettings();
      });
    });
    containerEl.createEl("h3", { text: "Property Mappings" });
    const propertyMappingExplanation = containerEl.createEl("div");
    propertyMappingExplanation.innerHTML = `
		<p>Allow you to remap the metadata fields of newly created media db entries.</p>
		<p>
			The different options are:
			<lu>
				<li>"default": does no remapping and keeps the metadata field as it is</li>
				<li>"remap": renames the metadata field to what ever you specify</li>
				<li>"remove": removes the metadata field entirely</li>
			</lu>
		</p>
		<p>
			Don't forget to save your changes using the save button for each individual category.
		</p>`;
    new PropertyMappingModelsComponent_default({
      target: this.containerEl,
      props: {
        models: this.plugin.settings.propertyMappingModels.map((x) => x.copy()),
        save: (model) => {
          const propertyMappingModels = [];
          for (const model2 of this.plugin.settings.propertyMappingModels) {
            if (model2.type === model.type) {
              propertyMappingModels.push(model);
            } else {
              propertyMappingModels.push(model2);
            }
          }
          this.plugin.settings.propertyMappingModels = propertyMappingModels;
          new import_obsidian6.Notice(`MDB: Property Mappings for ${model.type} saved successfully.`);
          this.plugin.saveSettings();
        }
      }
    });
  }
};

// src/api/APIManager.ts
var APIManager = class {
  constructor() {
    this.apis = [];
  }
  query(query, apisToQuery) {
    return __async(this, null, function* () {
      console.debug(`MDB | api manager queried with "${query}"`);
      let res = [];
      for (const api of this.apis) {
        if (apisToQuery.contains(api.apiName)) {
          const apiRes = yield api.searchByTitle(query);
          res = res.concat(apiRes);
        }
      }
      return res;
    });
  }
  queryDetailedInfo(item) {
    return __async(this, null, function* () {
      return yield this.queryDetailedInfoById(item.id, item.dataSource);
    });
  }
  queryDetailedInfoById(id, apiName) {
    return __async(this, null, function* () {
      for (const api of this.apis) {
        if (api.apiName === apiName) {
          return api.getById(id);
        }
      }
    });
  }
  getApiByName(name) {
    for (const api of this.apis) {
      if (api.apiName === name) {
        return api;
      }
    }
    return null;
  }
  registerAPI(api) {
    this.apis.push(api);
  }
};

// src/api/APIModel.ts
var APIModel = class {
  hasType(type) {
    return this.types.contains(type);
  }
  hasTypeOverlap(types) {
    for (const type of types) {
      if (this.hasType(type)) {
        return true;
      }
    }
    return false;
  }
};

// src/api/apis/OMDbAPI.ts
var OMDbAPI = class extends APIModel {
  constructor(plugin) {
    super();
    this.plugin = plugin;
    this.apiName = "OMDbAPI";
    this.apiDescription = "A free API for Movies, Series and Games.";
    this.apiUrl = "http://www.omdbapi.com/";
    this.types = [MediaType.Movie, MediaType.Series, MediaType.Game];
    this.typeMappings = new Map();
    this.typeMappings.set("movie", "movie");
    this.typeMappings.set("series", "series");
    this.typeMappings.set("game", "game");
  }
  searchByTitle(title) {
    return __async(this, null, function* () {
      console.log(`MDB | api "${this.apiName}" queried by Title`);
      const searchUrl = `http://www.omdbapi.com/?s=${encodeURIComponent(title)}&apikey=${this.plugin.settings.OMDbKey}`;
      const fetchData = yield fetch(searchUrl);
      if (fetchData.status === 401) {
        throw Error(`MDB | Authentication for ${this.apiName} failed. Check the API key.`);
      }
      if (fetchData.status !== 200) {
        throw Error(`MDB | Received status code ${fetchData.status} from an API.`);
      }
      const data = yield fetchData.json();
      if (data.Response === "False") {
        if (data.Error === "Movie not found!") {
          return [];
        }
        throw Error(`MDB | Received error from ${this.apiName}: 
${JSON.stringify(data, void 0, 4)}`);
      }
      if (!data.Search) {
        return [];
      }
      console.debug(data.Search);
      const ret = [];
      for (const result of data.Search) {
        const type = this.typeMappings.get(result.Type.toLowerCase());
        if (type === void 0) {
          continue;
        }
        if (type === "movie") {
          ret.push(new MovieModel({
            type,
            title: result.Title,
            englishTitle: result.Title,
            year: result.Year,
            dataSource: this.apiName,
            id: result.imdbID
          }));
        } else if (type === "series") {
          ret.push(new SeriesModel({
            type,
            title: result.Title,
            englishTitle: result.Title,
            year: result.Year,
            dataSource: this.apiName,
            id: result.imdbID
          }));
        } else if (type === "game") {
          ret.push(new GameModel({
            type,
            title: result.Title,
            englishTitle: result.Title,
            year: result.Year,
            dataSource: this.apiName,
            id: result.imdbID
          }));
        }
      }
      return ret;
    });
  }
  getById(id) {
    return __async(this, null, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v;
      console.log(`MDB | api "${this.apiName}" queried by ID`);
      const searchUrl = `http://www.omdbapi.com/?i=${encodeURIComponent(id)}&apikey=${this.plugin.settings.OMDbKey}`;
      const fetchData = yield fetch(searchUrl);
      if (fetchData.status === 401) {
        throw Error(`MDB | Authentication for ${this.apiName} failed. Check the API key.`);
      }
      if (fetchData.status !== 200) {
        throw Error(`MDB | Received status code ${fetchData.status} from an API.`);
      }
      const result = yield fetchData.json();
      if (result.Response === "False") {
        throw Error(`MDB | Received error from ${this.apiName}: ${result.Error}`);
      }
      const type = this.typeMappings.get(result.Type.toLowerCase());
      if (type === void 0) {
        throw Error(`${result.type.toLowerCase()} is an unsupported type.`);
      }
      if (type === "movie") {
        const model = new MovieModel({
          type,
          title: result.Title,
          englishTitle: result.Title,
          year: result.Year,
          dataSource: this.apiName,
          url: `https://www.imdb.com/title/${result.imdbID}/`,
          id: result.imdbID,
          genres: (_b = (_a = result.Genre) == null ? void 0 : _a.split(", ")) != null ? _b : [],
          producer: (_c = result.Director) != null ? _c : "unknown",
          duration: (_d = result.Runtime) != null ? _d : "unknown",
          onlineRating: Number.parseFloat((_e = result.imdbRating) != null ? _e : 0),
          actors: (_g = (_f = result.Actors) == null ? void 0 : _f.split(", ")) != null ? _g : [],
          image: (_h = result.Poster) != null ? _h : "",
          released: true,
          streamingServices: [],
          premiere: (_i = new Date(result.Released).toLocaleDateString()) != null ? _i : "unknown",
          userData: {
            watched: false,
            lastWatched: "",
            personalRating: 0
          }
        });
        return model;
      } else if (type === "series") {
        const model = new SeriesModel({
          type,
          title: result.Title,
          englishTitle: result.Title,
          year: result.Year,
          dataSource: this.apiName,
          url: `https://www.imdb.com/title/${result.imdbID}/`,
          id: result.imdbID,
          genres: (_k = (_j = result.Genre) == null ? void 0 : _j.split(", ")) != null ? _k : [],
          studios: [result.Director],
          episodes: 0,
          duration: (_l = result.Runtime) != null ? _l : "unknown",
          onlineRating: Number.parseFloat((_m = result.imdbRating) != null ? _m : 0),
          actors: (_o = (_n = result.Actors) == null ? void 0 : _n.split(", ")) != null ? _o : [],
          image: (_p = result.Poster) != null ? _p : "",
          released: true,
          streamingServices: [],
          airing: false,
          airedFrom: (_q = new Date(result.Released).toLocaleDateString()) != null ? _q : "unknown",
          airedTo: "unknown",
          userData: {
            watched: false,
            lastWatched: "",
            personalRating: 0
          }
        });
        return model;
      } else if (type === "game") {
        const model = new GameModel({
          type,
          title: result.Title,
          englishTitle: result.Title,
          year: result.Year,
          dataSource: this.apiName,
          url: `https://www.imdb.com/title/${result.imdbID}/`,
          id: result.imdbID,
          genres: (_s = (_r = result.Genre) == null ? void 0 : _r.split(", ")) != null ? _s : [],
          onlineRating: Number.parseFloat((_t = result.imdbRating) != null ? _t : 0),
          image: (_u = result.Poster) != null ? _u : "",
          released: true,
          releaseDate: (_v = new Date(result.Released).toLocaleDateString()) != null ? _v : "unknown",
          userData: {
            played: false,
            personalRating: 0
          }
        });
        return model;
      }
      return;
    });
  }
};

// src/api/apis/MALAPI.ts
var MALAPI = class extends APIModel {
  constructor(plugin) {
    super();
    this.plugin = plugin;
    this.apiName = "MALAPI";
    this.apiDescription = "A free API for Anime. Some results may take a long time to load.";
    this.apiUrl = "https://jikan.moe/";
    this.types = [MediaType.Movie, MediaType.Series];
    this.typeMappings = new Map();
    this.typeMappings.set("movie", "movie");
    this.typeMappings.set("special", "special");
    this.typeMappings.set("tv", "series");
    this.typeMappings.set("ova", "ova");
  }
  searchByTitle(title) {
    return __async(this, null, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s;
      console.log(`MDB | api "${this.apiName}" queried by Title`);
      const searchUrl = `https://api.jikan.moe/v4/anime?q=${encodeURIComponent(title)}&limit=20${this.plugin.settings.sfwFilter ? "&sfw" : ""}`;
      const fetchData = yield fetch(searchUrl);
      console.debug(fetchData);
      if (fetchData.status !== 200) {
        throw Error(`MDB | Received status code ${fetchData.status} from an API.`);
      }
      const data = yield fetchData.json();
      console.debug(data);
      const ret = [];
      for (const result of data.data) {
        const type = this.typeMappings.get((_a = result.type) == null ? void 0 : _a.toLowerCase());
        if (type === void 0) {
          ret.push(new MovieModel({
            subType: "",
            title: result.title,
            englishTitle: (_b = result.title_english) != null ? _b : result.title,
            year: (_g = (_f = result.year) != null ? _f : (_e = (_d = (_c = result.aired) == null ? void 0 : _c.prop) == null ? void 0 : _d.from) == null ? void 0 : _e.year) != null ? _g : "",
            dataSource: this.apiName,
            id: result.mal_id
          }));
        }
        if (type === "movie" || type === "special") {
          ret.push(new MovieModel({
            subType: type,
            title: result.title,
            englishTitle: (_h = result.title_english) != null ? _h : result.title,
            year: (_m = (_l = result.year) != null ? _l : (_k = (_j = (_i = result.aired) == null ? void 0 : _i.prop) == null ? void 0 : _j.from) == null ? void 0 : _k.year) != null ? _m : "",
            dataSource: this.apiName,
            id: result.mal_id
          }));
        } else if (type === "series" || type === "ova") {
          ret.push(new SeriesModel({
            subType: type,
            title: result.title,
            englishTitle: (_n = result.title_english) != null ? _n : result.title,
            year: (_s = (_r = result.year) != null ? _r : (_q = (_p = (_o = result.aired) == null ? void 0 : _o.prop) == null ? void 0 : _p.from) == null ? void 0 : _q.year) != null ? _s : "",
            dataSource: this.apiName,
            id: result.mal_id
          }));
        }
      }
      return ret;
    });
  }
  getById(id) {
    return __async(this, null, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _A, _B, _C, _D, _E, _F, _G, _H, _I, _J, _K, _L, _M, _N, _O, _P, _Q, _R, _S, _T, _U, _V, _W, _X, _Y, _Z, __, _$, _aa, _ba, _ca, _da, _ea, _fa;
      console.log(`MDB | api "${this.apiName}" queried by ID`);
      const searchUrl = `https://api.jikan.moe/v4/anime/${encodeURIComponent(id)}/full`;
      const fetchData = yield fetch(searchUrl);
      if (fetchData.status !== 200) {
        throw Error(`MDB | Received status code ${fetchData.status} from an API.`);
      }
      const data = yield fetchData.json();
      console.debug(data);
      const result = data.data;
      const type = this.typeMappings.get((_a = result.type) == null ? void 0 : _a.toLowerCase());
      if (type === void 0) {
        const model = new MovieModel({
          subType: "",
          title: result.title,
          englishTitle: (_b = result.title_english) != null ? _b : result.title,
          year: (_g = (_f = result.year) != null ? _f : (_e = (_d = (_c = result.aired) == null ? void 0 : _c.prop) == null ? void 0 : _d.from) == null ? void 0 : _e.year) != null ? _g : "",
          dataSource: this.apiName,
          url: result.url,
          id: result.mal_id,
          genres: (_i = (_h = result.genres) == null ? void 0 : _h.map((x) => x.name)) != null ? _i : [],
          producer: (_k = (_j = result.studios) == null ? void 0 : _j.map((x) => x.name).join(", ")) != null ? _k : "unknown",
          duration: (_l = result.duration) != null ? _l : "unknown",
          onlineRating: (_m = result.score) != null ? _m : 0,
          actors: [],
          image: (_p = (_o = (_n = result.images) == null ? void 0 : _n.jpg) == null ? void 0 : _o.image_url) != null ? _p : "",
          released: true,
          premiere: (_r = new Date((_q = result.aired) == null ? void 0 : _q.from).toLocaleDateString()) != null ? _r : "unknown",
          streamingServices: (_t = (_s = result.streaming) == null ? void 0 : _s.map((x) => x.name)) != null ? _t : [],
          userData: {
            watched: false,
            lastWatched: "",
            personalRating: 0
          }
        });
        return model;
      }
      if (type === "movie" || type === "special") {
        const model = new MovieModel({
          subType: type,
          title: result.title,
          englishTitle: (_u = result.title_english) != null ? _u : result.title,
          year: (_z = (_y = result.year) != null ? _y : (_x = (_w = (_v = result.aired) == null ? void 0 : _v.prop) == null ? void 0 : _w.from) == null ? void 0 : _x.year) != null ? _z : "",
          dataSource: this.apiName,
          url: result.url,
          id: result.mal_id,
          genres: (_B = (_A = result.genres) == null ? void 0 : _A.map((x) => x.name)) != null ? _B : [],
          producer: (_D = (_C = result.studios) == null ? void 0 : _C.map((x) => x.name).join(", ")) != null ? _D : "unknown",
          duration: (_E = result.duration) != null ? _E : "unknown",
          onlineRating: (_F = result.score) != null ? _F : 0,
          actors: [],
          image: (_I = (_H = (_G = result.images) == null ? void 0 : _G.jpg) == null ? void 0 : _H.image_url) != null ? _I : "",
          released: true,
          premiere: (_K = new Date((_J = result.aired) == null ? void 0 : _J.from).toLocaleDateString()) != null ? _K : "unknown",
          streamingServices: (_M = (_L = result.streaming) == null ? void 0 : _L.map((x) => x.name)) != null ? _M : [],
          userData: {
            watched: false,
            lastWatched: "",
            personalRating: 0
          }
        });
        return model;
      } else if (type === "series" || type === "ova") {
        const model = new SeriesModel({
          subType: type,
          title: result.title,
          englishTitle: (_N = result.title_english) != null ? _N : result.title,
          year: (_S = (_R = result.year) != null ? _R : (_Q = (_P = (_O = result.aired) == null ? void 0 : _O.prop) == null ? void 0 : _P.from) == null ? void 0 : _Q.year) != null ? _S : "",
          dataSource: this.apiName,
          url: result.url,
          id: result.mal_id,
          genres: (_U = (_T = result.genres) == null ? void 0 : _T.map((x) => x.name)) != null ? _U : [],
          studios: (_W = (_V = result.studios) == null ? void 0 : _V.map((x) => x.name)) != null ? _W : [],
          episodes: result.episodes,
          duration: (_X = result.duration) != null ? _X : "unknown",
          onlineRating: (_Y = result.score) != null ? _Y : 0,
          streamingServices: (__ = (_Z = result.streaming) == null ? void 0 : _Z.map((x) => x.name)) != null ? __ : [],
          image: (_ba = (_aa = (_$ = result.images) == null ? void 0 : _$.jpg) == null ? void 0 : _aa.image_url) != null ? _ba : "",
          released: true,
          airedFrom: (_da = new Date((_ca = result.aired) == null ? void 0 : _ca.from).toLocaleDateString()) != null ? _da : "unknown",
          airedTo: (_fa = new Date((_ea = result.aired) == null ? void 0 : _ea.to).toLocaleDateString()) != null ? _fa : "unknown",
          airing: result.airing,
          userData: {
            watched: false,
            lastWatched: "",
            personalRating: 0
          }
        });
        return model;
      }
      return;
    });
  }
};

// src/api/apis/WikipediaAPI.ts
var WikipediaAPI = class extends APIModel {
  constructor(plugin) {
    super();
    this.plugin = plugin;
    this.apiName = "Wikipedia API";
    this.apiDescription = "The API behind Wikipedia";
    this.apiUrl = "https://www.wikipedia.com";
    this.types = [MediaType.Wiki];
  }
  searchByTitle(title) {
    return __async(this, null, function* () {
      console.log(`MDB | api "${this.apiName}" queried by Title`);
      const searchUrl = `https://en.wikipedia.org/w/api.php?action=query&list=search&srsearch=${encodeURIComponent(title)}&srlimit=20&utf8=&format=json&origin=*`;
      const fetchData = yield fetch(searchUrl);
      console.debug(fetchData);
      if (fetchData.status !== 200) {
        throw Error(`MDB | Received status code ${fetchData.status} from an API.`);
      }
      const data = yield fetchData.json();
      console.debug(data);
      const ret = [];
      for (const result of data.query.search) {
        ret.push(new WikiModel({
          type: "wiki",
          title: result.title,
          englishTitle: result.title,
          year: "",
          dataSource: this.apiName,
          id: result.pageid
        }));
      }
      return ret;
    });
  }
  getById(id) {
    return __async(this, null, function* () {
      var _a, _b;
      console.log(`MDB | api "${this.apiName}" queried by ID`);
      const searchUrl = `https://en.wikipedia.org/w/api.php?action=query&prop=info&pageids=${encodeURIComponent(id)}&inprop=url&format=json&origin=*`;
      const fetchData = yield fetch(searchUrl);
      if (fetchData.status !== 200) {
        throw Error(`MDB | Received status code ${fetchData.status} from an API.`);
      }
      const data = yield fetchData.json();
      console.debug(data);
      const result = Object.entries((_a = data == null ? void 0 : data.query) == null ? void 0 : _a.pages)[0][1];
      const model = new WikiModel({
        type: "wiki",
        title: result.title,
        englishTitle: result.title,
        year: "",
        dataSource: this.apiName,
        url: result.fullurl,
        id: result.pageid,
        wikiUrl: result.fullurl,
        lastUpdated: (_b = new Date(result.touched).toLocaleDateString()) != null ? _b : "unknown",
        length: result.length,
        userData: {}
      });
      return model;
    });
  }
};

// src/api/apis/MusicBrainzAPI.ts
var import_obsidian7 = __toModule(require("obsidian"));
var MusicBrainzAPI = class extends APIModel {
  constructor(plugin) {
    super();
    this.plugin = plugin;
    this.apiName = "MusicBrainz API";
    this.apiDescription = "Free API for music albums.";
    this.apiUrl = "https://musicbrainz.org/";
    this.types = [MediaType.MusicRelease];
  }
  searchByTitle(title) {
    return __async(this, null, function* () {
      console.log(`MDB | api "${this.apiName}" queried by Title`);
      const searchUrl = `https://musicbrainz.org/ws/2/release-group?query=${encodeURIComponent(title)}&limit=20&fmt=json`;
      const fetchData = yield (0, import_obsidian7.requestUrl)({
        url: searchUrl,
        headers: {
          "User-Agent": `${pluginName}/${mediaDbVersion} (${contactEmail})`
        }
      });
      console.debug(fetchData);
      if (fetchData.status !== 200) {
        throw Error(`MDB | Received status code ${fetchData.status} from an API.`);
      }
      const data = yield fetchData.json;
      console.debug(data);
      const ret = [];
      for (const result of data["release-groups"]) {
        ret.push(new MusicReleaseModel({
          type: "musicRelease",
          title: result.title,
          englishTitle: result.title,
          year: new Date(result["first-release-date"]).getFullYear().toString(),
          dataSource: this.apiName,
          url: "",
          id: result.id,
          artists: result["artist-credit"].map((a) => a.name),
          subType: result["primary-type"]
        }));
      }
      return ret;
    });
  }
  getById(id) {
    return __async(this, null, function* () {
      console.log(`MDB | api "${this.apiName}" queried by ID`);
      const searchUrl = `https://musicbrainz.org/ws/2/release-group/${encodeURIComponent(id)}?inc=releases+artists+tags+ratings+genres&fmt=json`;
      const fetchData = yield (0, import_obsidian7.requestUrl)({
        url: searchUrl,
        headers: {
          "User-Agent": `${pluginName}/${mediaDbVersion} (${contactEmail})`
        }
      });
      if (fetchData.status !== 200) {
        throw Error(`MDB | Received status code ${fetchData.status} from an API.`);
      }
      const data = yield fetchData.json;
      console.debug(data);
      const result = data;
      const model = new MusicReleaseModel({
        type: "musicRelease",
        title: result.title,
        englishTitle: result.title,
        year: new Date(result["first-release-date"]).getFullYear().toString(),
        dataSource: this.apiName,
        url: "",
        id: result.id,
        artists: result["artist-credit"].map((a) => a.name),
        genres: result.genres.map((g) => g.name),
        subType: result["primary-type"],
        rating: result.rating.value * 2,
        userData: {
          personalRating: 0
        }
      });
      return model;
    });
  }
};

// src/api/apis/SteamAPI.ts
var import_obsidian8 = __toModule(require("obsidian"));
var SteamAPI = class extends APIModel {
  constructor(plugin) {
    super();
    this.plugin = plugin;
    this.apiName = "SteamAPI";
    this.apiDescription = "A free API for all Steam games.";
    this.apiUrl = "http://www.steampowered.com/";
    this.types = [MediaType.Game];
    this.typeMappings = new Map();
    this.typeMappings.set("game", "game");
  }
  searchByTitle(title) {
    return __async(this, null, function* () {
      console.log(`MDB | api "${this.apiName}" queried by Title`);
      const searchUrl = `http://api.steampowered.com/ISteamApps/GetAppList/v0002/?format=json`;
      const fetchData = yield (0, import_obsidian8.requestUrl)({
        url: searchUrl
      });
      if (fetchData.status !== 200) {
        throw Error(`MDB | Received status code ${fetchData.status} from an API.`);
      }
      const data = yield fetchData.json;
      console.debug(data);
      const filteredData = [];
      for (const app of data.applist.apps) {
        if (app.name.toLowerCase().includes(title.toLowerCase())) {
          filteredData.push(app);
        }
        if (filteredData.length > 20) {
          break;
        }
      }
      const ret = [];
      for (const result of filteredData) {
        ret.push(new GameModel({
          type: MediaType.Game,
          title: result.name,
          englishTitle: result.name,
          year: "",
          dataSource: this.apiName,
          id: result.appid
        }));
      }
      return ret;
    });
  }
  getById(id) {
    return __async(this, null, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h;
      console.log(`MDB | api "${this.apiName}" queried by ID`);
      const searchUrl = `http://store.steampowered.com/api/appdetails?appids=${encodeURIComponent(id)}&l=en`;
      const fetchData = yield (0, import_obsidian8.requestUrl)({
        url: searchUrl
      });
      if (fetchData.status !== 200) {
        throw Error(`MDB | Received status code ${fetchData.status} from an API.`);
      }
      console.debug(yield fetchData.json);
      let result;
      for (const [key, value] of Object.entries(yield fetchData.json)) {
        if (key === String(id)) {
          result = value.data;
        }
      }
      if (!result) {
        throw Error(`MDB | API returned invalid data.`);
      }
      console.debug(result);
      const model = new GameModel({
        type: MediaType.Game,
        title: result.name,
        englishTitle: result.name,
        year: new Date(result.release_date.date).getFullYear().toString(),
        dataSource: this.apiName,
        url: `https://store.steampowered.com/app/${result.steam_appid}`,
        id: result.steam_appid,
        genres: (_b = (_a = result.genres) == null ? void 0 : _a.map((x) => x.description)) != null ? _b : [],
        onlineRating: Number.parseFloat((_d = (_c = result.metacritic) == null ? void 0 : _c.score) != null ? _d : 0),
        image: (_e = result.header_image) != null ? _e : "",
        released: !((_f = result.release_date) == null ? void 0 : _f.comming_soon),
        releaseDate: (_h = new Date((_g = result.release_date) == null ? void 0 : _g.date).toLocaleDateString()) != null ? _h : "unknown",
        userData: {
          played: false,
          personalRating: 0
        }
      });
      return model;
    });
  }
};

// src/api/apis/BoardGameGeekAPI.ts
var import_obsidian9 = __toModule(require("obsidian"));
var BoardGameGeekAPI = class extends APIModel {
  constructor(plugin) {
    super();
    this.plugin = plugin;
    this.apiName = "BoardGameGeekAPI";
    this.apiDescription = "A free API for BoardGameGeek things.";
    this.apiUrl = "https://api.geekdo.com/xmlapi";
    this.types = [MediaType.BoardGame];
  }
  searchByTitle(title) {
    return __async(this, null, function* () {
      var _a, _b, _c, _d;
      console.log(`MDB | api "${this.apiName}" queried by Title`);
      const searchUrl = `${this.apiUrl}/search?search=${encodeURIComponent(title)}`;
      const fetchData = yield (0, import_obsidian9.requestUrl)({
        url: searchUrl
      });
      if (fetchData.status !== 200) {
        throw Error(`MDB | Received status code ${fetchData.status} from an API.`);
      }
      const data = fetchData.text;
      const response = new window.DOMParser().parseFromString(data, "text/xml");
      console.debug(response);
      const ret = [];
      for (const boardgame of Array.from(response.querySelectorAll("boardgame"))) {
        const id = boardgame.attributes.getNamedItem("objectid").value;
        const title2 = (_b = (_a = boardgame.querySelector("name[primary=true]")) == null ? void 0 : _a.textContent) != null ? _b : boardgame.querySelector("name").textContent;
        const year = (_d = (_c = boardgame.querySelector("yearpublished")) == null ? void 0 : _c.textContent) != null ? _d : "";
        ret.push(new BoardGameModel({
          dataSource: this.apiName,
          id,
          title: title2,
          englishTitle: title2,
          year
        }));
      }
      return ret;
    });
  }
  getById(id) {
    return __async(this, null, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n;
      console.log(`MDB | api "${this.apiName}" queried by ID`);
      const searchUrl = `${this.apiUrl}/boardgame/${encodeURIComponent(id)}?stats=1`;
      const fetchData = yield (0, import_obsidian9.requestUrl)({
        url: searchUrl
      });
      if (fetchData.status !== 200) {
        throw Error(`MDB | Received status code ${fetchData.status} from an API.`);
      }
      const data = fetchData.text;
      const response = new window.DOMParser().parseFromString(data, "text/xml");
      console.debug(response);
      const boardgame = response.querySelector("boardgame");
      const title = boardgame.querySelector("name[primary=true]").textContent;
      const year = (_b = (_a = boardgame.querySelector("yearpublished")) == null ? void 0 : _a.textContent) != null ? _b : "";
      const image = (_d = (_c = boardgame.querySelector("image")) == null ? void 0 : _c.textContent) != null ? _d : void 0;
      const onlineRating = Number.parseFloat((_f = (_e = boardgame.querySelector("statistics ratings average")) == null ? void 0 : _e.textContent) != null ? _f : "0");
      const genres = Array.from(boardgame.querySelectorAll("boardgamecategory")).map((n) => n.textContent);
      const complexityRating = Number.parseFloat((_h = (_g = boardgame.querySelector("averageweight")) == null ? void 0 : _g.textContent) != null ? _h : "0");
      const minPlayers = Number.parseFloat((_j = (_i = boardgame.querySelector("minplayers")) == null ? void 0 : _i.textContent) != null ? _j : "0");
      const maxPlayers = Number.parseFloat((_l = (_k = boardgame.querySelector("maxplayers")) == null ? void 0 : _k.textContent) != null ? _l : "0");
      const playtime = ((_n = (_m = boardgame.querySelector("playingtime")) == null ? void 0 : _m.textContent) != null ? _n : "unknown") + " minutes";
      const publishers = Array.from(boardgame.querySelectorAll("boardgamepublisher")).map((n) => n.textContent);
      const model = new BoardGameModel({
        title,
        englishTitle: title,
        year: year === "0" ? "" : year,
        dataSource: this.apiName,
        url: `https://boardgamegeek.com/boardgame/${id}`,
        id,
        genres,
        onlineRating,
        complexityRating,
        minPlayers,
        maxPlayers,
        playtime,
        publishers,
        image,
        released: true,
        userData: {
          played: false,
          personalRating: 0
        }
      });
      return model;
    });
  }
};

// src/settings/PropertyMapper.ts
var PropertyMapper = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  convertObject(obj) {
    if (!obj.hasOwnProperty("type")) {
      return obj;
    }
    if (MEDIA_TYPES.filter((x) => x.toString() == obj.type).length < 1) {
      return obj;
    }
    const propertyMappings = this.plugin.settings.propertyMappingModels.find((x) => x.type === obj.type).properties;
    const newObj = {};
    for (const [key, value] of Object.entries(obj)) {
      for (const propertyMapping of propertyMappings) {
        if (propertyMapping.property === key) {
          if (propertyMapping.mapping === PropertyMappingOption.Map) {
            newObj[propertyMapping.newProperty] = value;
          } else if (propertyMapping.mapping === PropertyMappingOption.Remove) {
          } else if (propertyMapping.mapping === PropertyMappingOption.Default) {
            newObj[key] = value;
          }
          break;
        }
      }
    }
    return newObj;
  }
  convertObjectBack(obj) {
    if (!obj.hasOwnProperty("type")) {
      return obj;
    }
    if (MEDIA_TYPES.contains(obj.type)) {
      return obj;
    }
    const propertyMappings = this.plugin.settings.propertyMappingModels.find((x) => x.type === obj.type).properties;
    const originalObj = {};
    objLoop:
      for (const [key, value] of Object.entries(obj)) {
        for (const propertyMapping of propertyMappings) {
          if (propertyMapping.property === key) {
            originalObj[key] = value;
            continue objLoop;
          }
        }
        for (const propertyMapping of propertyMappings) {
          if (propertyMapping.newProperty === key) {
            originalObj[propertyMapping.property] = value;
            continue objLoop;
          }
        }
      }
    return originalObj;
  }
};

// src/utils/YAMLConverter.ts
var YAMLConverter = class {
  static toYaml(obj) {
    let output = "";
    for (const [key, value] of Object.entries(obj)) {
      output += `${key}: ${YAMLConverter.toYamlString(value, 0)}
`;
    }
    return output;
  }
  static toYamlString(value, indentation) {
    if (value == null) {
      return "null";
    }
    if (typeof value === "boolean") {
      return value ? "true" : "false";
    } else if (typeof value === "number") {
      return value.toString();
    } else if (typeof value === "string") {
      return '"' + value.replace('"', '\\"') + '"';
    } else if (typeof value === "object") {
      let output = "";
      if (Array.isArray(value)) {
        for (const valueElement of value) {
          output += `
${YAMLConverter.calculateSpacing(indentation)}  - ${YAMLConverter.toYamlString(valueElement, indentation + 1)}`;
        }
      } else {
        for (const [objKey, objValue] of Object.entries(value)) {
          output += `
${YAMLConverter.calculateSpacing(indentation)}    ${objKey}: ${YAMLConverter.toYamlString(objValue, indentation + 1)}`;
        }
      }
      return output;
    }
  }
  static calculateSpacing(indentation) {
    return " ".repeat(indentation * 4);
  }
};

// src/modals/MediaDbFolderImportModal.ts
var import_obsidian10 = __toModule(require("obsidian"));
var MediaDbFolderImportModal = class extends import_obsidian10.Modal {
  constructor(app, plugin, onSubmit) {
    super(app);
    this.plugin = plugin;
    this.onSubmit = onSubmit;
    this.selectedApi = plugin.apiManager.apis[0].apiName;
  }
  submit() {
    this.onSubmit(this.selectedApi, this.titleFieldName, this.appendContent);
    this.close();
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: "Import folder as Media DB entries" });
    const apiSelectorWrapper = contentEl.createEl("div", { cls: "media-db-plugin-list-wrapper" });
    const apiSelectorTextWrapper = apiSelectorWrapper.createEl("div", { cls: "media-db-plugin-list-text-wrapper" });
    apiSelectorTextWrapper.createEl("span", { text: "API to search", cls: "media-db-plugin-list-text" });
    const apiSelectorComponent = new import_obsidian10.DropdownComponent(apiSelectorWrapper);
    apiSelectorComponent.onChange((value) => {
      this.selectedApi = value;
    });
    for (const api of this.plugin.apiManager.apis) {
      apiSelectorComponent.addOption(api.apiName, api.apiName);
    }
    apiSelectorWrapper.appendChild(apiSelectorComponent.selectEl);
    contentEl.createDiv({ cls: "media-db-plugin-spacer" });
    contentEl.createEl("h3", { text: "Append note content to Media DB entry." });
    const appendContentToggleElementWrapper = contentEl.createEl("div", { cls: "media-db-plugin-list-wrapper" });
    const appendContentToggleTextWrapper = appendContentToggleElementWrapper.createEl("div", { cls: "media-db-plugin-list-text-wrapper" });
    appendContentToggleTextWrapper.createEl("span", {
      text: "If this is enabled, the plugin will override metadata fields with the same name.",
      cls: "media-db-plugin-list-text"
    });
    const appendContentToggleComponentWrapper = appendContentToggleElementWrapper.createEl("div", { cls: "media-db-plugin-list-toggle" });
    const appendContentToggle = new import_obsidian10.ToggleComponent(appendContentToggleElementWrapper);
    appendContentToggle.setValue(false);
    appendContentToggle.onChange((value) => this.appendContent = value);
    appendContentToggleComponentWrapper.appendChild(appendContentToggle.toggleEl);
    contentEl.createDiv({ cls: "media-db-plugin-spacer" });
    contentEl.createEl("h3", { text: "The name of the metadata field that should be used as the title to query." });
    const placeholder = "title";
    const titleFieldNameComponent = new import_obsidian10.TextComponent(contentEl);
    titleFieldNameComponent.inputEl.style.width = "100%";
    titleFieldNameComponent.setPlaceholder(placeholder);
    titleFieldNameComponent.onChange((value) => this.titleFieldName = value);
    titleFieldNameComponent.inputEl.addEventListener("keydown", (ke) => {
      if (ke.key === "Enter") {
        this.submit();
      }
    });
    contentEl.appendChild(titleFieldNameComponent.inputEl);
    contentEl.createDiv({ cls: "media-db-plugin-spacer" });
    new import_obsidian10.Setting(contentEl).addButton((btn) => {
      btn.setButtonText("Cancel");
      btn.onClick(() => this.close());
      btn.buttonEl.addClass("media-db-plugin-button");
    }).addButton((btn) => {
      btn.setButtonText("Ok");
      btn.setCta();
      btn.onClick(() => {
        this.submit();
      });
      btn.buttonEl.addClass("media-db-plugin-button");
      this.searchBtn = btn;
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/modals/MediaDbAdvancedSearchModal.ts
var import_obsidian11 = __toModule(require("obsidian"));
var MediaDbAdvancedSearchModal = class extends import_obsidian11.Modal {
  constructor(plugin, advancedSearchModalOptions) {
    advancedSearchModalOptions = Object.assign({}, ADVANCED_SEARCH_MODAL_DEFAULT_OPTIONS, advancedSearchModalOptions);
    super(plugin.app);
    this.plugin = plugin;
    this.selectedApis = [];
    this.title = advancedSearchModalOptions.modalTitle;
    this.query = advancedSearchModalOptions.prefilledSearchString;
    for (const api of this.plugin.apiManager.apis) {
      this.selectedApis.push({ name: api.apiName, selected: advancedSearchModalOptions.preselectedAPIs.contains(api.apiName) });
    }
  }
  setSubmitCallback(submitCallback) {
    this.submitCallback = submitCallback;
  }
  setCloseCallback(closeCallback) {
    this.closeCallback = closeCallback;
  }
  keyPressCallback(event) {
    if (event.key === "Enter") {
      this.search();
    }
  }
  search() {
    return __async(this, null, function* () {
      if (!this.query || this.query.length < 3) {
        new import_obsidian11.Notice("MDB | Query too short");
        return;
      }
      const apis = this.selectedApis.filter((x) => x.selected).map((x) => x.name);
      if (apis.length === 0) {
        new import_obsidian11.Notice("MDB | No API selected");
        return;
      }
      if (!this.isBusy) {
        this.isBusy = true;
        this.searchBtn.setDisabled(false);
        this.searchBtn.setButtonText("Searching...");
        this.submitCallback({ query: this.query, apis });
      }
    });
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: this.title });
    const placeholder = "Search by title";
    const searchComponent = new import_obsidian11.TextComponent(contentEl);
    searchComponent.inputEl.style.width = "100%";
    searchComponent.setPlaceholder(placeholder);
    searchComponent.setValue(this.query);
    searchComponent.onChange((value) => this.query = value);
    searchComponent.inputEl.addEventListener("keydown", this.keyPressCallback.bind(this));
    contentEl.appendChild(searchComponent.inputEl);
    searchComponent.inputEl.focus();
    contentEl.createDiv({ cls: "media-db-plugin-spacer" });
    contentEl.createEl("h3", { text: "APIs to search" });
    for (const api of this.plugin.apiManager.apis) {
      const apiToggleListElementWrapper = contentEl.createEl("div", { cls: "media-db-plugin-list-wrapper" });
      const apiToggleTextWrapper = apiToggleListElementWrapper.createEl("div", { cls: "media-db-plugin-list-text-wrapper" });
      apiToggleTextWrapper.createEl("span", { text: api.apiName, cls: "media-db-plugin-list-text" });
      apiToggleTextWrapper.createEl("small", { text: api.apiDescription, cls: "media-db-plugin-list-text" });
      const apiToggleComponentWrapper = apiToggleListElementWrapper.createEl("div", { cls: "media-db-plugin-list-toggle" });
      const apiToggleComponent = new import_obsidian11.ToggleComponent(apiToggleComponentWrapper);
      apiToggleComponent.setTooltip(api.apiName);
      apiToggleComponent.setValue(this.selectedApis.find((x) => x.name === api.apiName).selected);
      apiToggleComponent.onChange((value) => {
        this.selectedApis.find((x) => x.name === api.apiName).selected = value;
      });
      apiToggleComponentWrapper.appendChild(apiToggleComponent.toggleEl);
    }
    contentEl.createDiv({ cls: "media-db-plugin-spacer" });
    new import_obsidian11.Setting(contentEl).addButton((btn) => {
      btn.setButtonText("Cancel");
      btn.onClick(() => this.close());
      btn.buttonEl.addClass("media-db-plugin-button");
    }).addButton((btn) => {
      btn.setButtonText("Ok");
      btn.setCta();
      btn.onClick(() => {
        this.search();
      });
      btn.buttonEl.addClass("media-db-plugin-button");
      this.searchBtn = btn;
    });
  }
  onClose() {
    this.closeCallback();
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/modals/MediaDbIdSearchModal.ts
var import_obsidian12 = __toModule(require("obsidian"));
var MediaDbIdSearchModal = class extends import_obsidian12.Modal {
  constructor(plugin, idSearchModalOptions) {
    idSearchModalOptions = Object.assign({}, ID_SEARCH_MODAL_DEFAULT_OPTIONS, idSearchModalOptions);
    super(plugin.app);
    this.plugin = plugin;
    this.title = idSearchModalOptions.modalTitle;
    this.selectedApi = idSearchModalOptions.preselectedAPI || plugin.apiManager.apis[0].apiName;
  }
  setSubmitCallback(submitCallback) {
    this.submitCallback = submitCallback;
  }
  setCloseCallback(closeCallback) {
    this.closeCallback = closeCallback;
  }
  keyPressCallback(event) {
    if (event.key === "Enter") {
      this.search();
    }
  }
  search() {
    return __async(this, null, function* () {
      if (!this.query) {
        new import_obsidian12.Notice("MDB | no Id entered");
        return;
      }
      if (!this.selectedApi) {
        new import_obsidian12.Notice("MDB | No API selected");
        return;
      }
      if (!this.isBusy) {
        this.isBusy = true;
        this.searchBtn.setDisabled(false);
        this.searchBtn.setButtonText("Searching...");
        this.submitCallback({ query: this.query, api: this.selectedApi });
      }
    });
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: this.title });
    const placeholder = "Search by id";
    const searchComponent = new import_obsidian12.TextComponent(contentEl);
    searchComponent.inputEl.style.width = "100%";
    searchComponent.setPlaceholder(placeholder);
    searchComponent.onChange((value) => this.query = value);
    searchComponent.inputEl.addEventListener("keydown", this.keyPressCallback.bind(this));
    contentEl.appendChild(searchComponent.inputEl);
    searchComponent.inputEl.focus();
    contentEl.createDiv({ cls: "media-db-plugin-spacer" });
    const apiSelectorWrapper = contentEl.createEl("div", { cls: "media-db-plugin-list-wrapper" });
    const apiSelectorTExtWrapper = apiSelectorWrapper.createEl("div", { cls: "media-db-plugin-list-text-wrapper" });
    apiSelectorTExtWrapper.createEl("span", { text: "API to search", cls: "media-db-plugin-list-text" });
    const apiSelectorComponent = new import_obsidian12.DropdownComponent(apiSelectorWrapper);
    apiSelectorComponent.onChange((value) => {
      this.selectedApi = value;
    });
    for (const api of this.plugin.apiManager.apis) {
      apiSelectorComponent.addOption(api.apiName, api.apiName);
    }
    apiSelectorWrapper.appendChild(apiSelectorComponent.selectEl);
    contentEl.createDiv({ cls: "media-db-plugin-spacer" });
    new import_obsidian12.Setting(contentEl).addButton((btn) => {
      btn.setButtonText("Cancel");
      btn.onClick(() => this.close());
      btn.buttonEl.addClass("media-db-plugin-button");
    }).addButton((btn) => {
      btn.setButtonText("Ok");
      btn.setCta();
      btn.onClick(() => {
        this.search();
      });
      btn.buttonEl.addClass("media-db-plugin-button");
      this.searchBtn = btn;
    });
  }
  onClose() {
    this.closeCallback();
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/modals/SelectModal.ts
var import_obsidian13 = __toModule(require("obsidian"));

// src/modals/SelectModalElement.ts
var SelectModalElement = class {
  constructor(value, parentElement, id, selectModal, active = false) {
    this.value = value;
    this.id = id;
    this.active = active;
    this.selectModal = selectModal;
    this.cssClass = "media-db-plugin-select-element";
    this.activeClass = "media-db-plugin-select-element-selected";
    this.hoverClass = "media-db-plugin-select-element-hover";
    this.element = parentElement.createDiv({ cls: this.cssClass });
    this.element.id = this.getHTMLId();
    this.element.on("click", "#" + this.getHTMLId(), () => {
      this.setActive(!this.active);
      if (!this.selectModal.allowMultiSelect) {
        this.selectModal.disableAllOtherElements(this.id);
      }
    });
    this.element.on("mouseenter", "#" + this.getHTMLId(), () => {
      this.setHighlighted(true);
    });
    this.element.on("mouseleave", "#" + this.getHTMLId(), () => {
      this.setHighlighted(false);
    });
  }
  getHTMLId() {
    return `media-db-plugin-select-element-${this.id}`;
  }
  isHighlighted() {
    return this.highlighted;
  }
  setHighlighted(value) {
    this.highlighted = value;
    if (this.highlighted) {
      this.addClass(this.hoverClass);
      this.selectModal.deHighlightAllOtherElements(this.id);
    } else {
      this.removeClass(this.hoverClass);
    }
  }
  isActive() {
    return this.active;
  }
  setActive(active) {
    this.active = active;
    this.update();
  }
  update() {
    if (this.active) {
      this.addClass(this.activeClass);
    } else {
      this.removeClass(this.activeClass);
    }
  }
  addClass(cssClass) {
    if (!this.element.hasClass(cssClass)) {
      this.element.addClass(cssClass);
    }
  }
  removeClass(cssClass) {
    if (this.element.hasClass(cssClass)) {
      this.element.removeClass(cssClass);
    }
  }
};

// src/modals/SelectModal.ts
var SelectModal = class extends import_obsidian13.Modal {
  constructor(app, elements, allowMultiSelect = true) {
    super(app);
    this.allowMultiSelect = allowMultiSelect;
    this.title = "";
    this.description = "";
    this.addSkipButton = false;
    this.cancelButton = void 0;
    this.skipButton = void 0;
    this.submitButton = void 0;
    this.elementWrapper = void 0;
    this.elements = elements;
    this.selectModalElements = [];
    this.scope.register([], "ArrowUp", (evt) => {
      this.highlightUp();
      evt.preventDefault();
    });
    this.scope.register([], "ArrowDown", (evt) => {
      this.highlightDown();
      evt.preventDefault();
    });
    this.scope.register([], "ArrowRight", () => {
      this.activateHighlighted();
    });
    this.scope.register([], " ", (evt) => {
      if (this.elementWrapper && this.elementWrapper === document.activeElement) {
        this.activateHighlighted();
        evt.preventDefault();
      }
    });
    this.scope.register([], "Enter", () => this.submit());
  }
  disableAllOtherElements(elementId) {
    for (const selectModalElement of this.selectModalElements) {
      if (selectModalElement.id !== elementId) {
        selectModalElement.setActive(false);
      }
    }
  }
  deHighlightAllOtherElements(elementId) {
    for (const selectModalElement of this.selectModalElements) {
      if (selectModalElement.id !== elementId) {
        selectModalElement.setHighlighted(false);
      }
    }
  }
  onOpen() {
    return __async(this, null, function* () {
      var _a;
      const { contentEl, titleEl } = this;
      titleEl.createEl("h2", { text: this.title });
      contentEl.addClass("media-db-plugin-select-modal");
      contentEl.createEl("p", { text: this.description });
      this.elementWrapper = contentEl.createDiv({ cls: "media-db-plugin-select-wrapper" });
      this.elementWrapper.tabIndex = 0;
      let i = 0;
      for (const element2 of this.elements) {
        const selectModalElement = new SelectModalElement(element2, this.elementWrapper, i, this, false);
        this.selectModalElements.push(selectModalElement);
        this.renderElement(element2, selectModalElement.element);
        i += 1;
      }
      (_a = this.selectModalElements.first()) == null ? void 0 : _a.element.scrollIntoView();
      const bottomSettingRow = new import_obsidian13.Setting(contentEl);
      bottomSettingRow.addButton((btn) => {
        btn.setButtonText("Cancel");
        btn.onClick(() => this.close());
        btn.buttonEl.addClass("media-db-plugin-button");
        this.cancelButton = btn;
      });
      if (this.addSkipButton) {
        bottomSettingRow.addButton((btn) => {
          btn.setButtonText("Skip");
          btn.onClick(() => this.skip());
          btn.buttonEl.addClass("media-db-plugin-button");
          this.skipButton = btn;
        });
      }
      bottomSettingRow.addButton((btn) => {
        btn.setButtonText("Ok");
        btn.setCta();
        btn.onClick(() => this.submit());
        btn.buttonEl.addClass("media-db-plugin-button");
        this.submitButton = btn;
      });
    });
  }
  activateHighlighted() {
    for (const selectModalElement of this.selectModalElements) {
      if (selectModalElement.isHighlighted()) {
        selectModalElement.setActive(!selectModalElement.isActive());
        if (!this.allowMultiSelect) {
          this.disableAllOtherElements(selectModalElement.id);
        }
      }
    }
  }
  highlightUp() {
    for (const selectModalElement of this.selectModalElements) {
      if (selectModalElement.isHighlighted()) {
        this.getPreviousSelectModalElement(selectModalElement).setHighlighted(true);
        return;
      }
    }
    this.selectModalElements.last().setHighlighted(true);
  }
  highlightDown() {
    for (const selectModalElement of this.selectModalElements) {
      if (selectModalElement.isHighlighted()) {
        this.getNextSelectModalElement(selectModalElement).setHighlighted(true);
        return;
      }
    }
    this.selectModalElements.first().setHighlighted(true);
  }
  getNextSelectModalElement(selectModalElement) {
    let nextId = selectModalElement.id + 1;
    nextId = mod(nextId, this.selectModalElements.length);
    return this.selectModalElements.filter((x) => x.id === nextId).first();
  }
  getPreviousSelectModalElement(selectModalElement) {
    let nextId = selectModalElement.id - 1;
    nextId = mod(nextId, this.selectModalElements.length);
    return this.selectModalElements.filter((x) => x.id === nextId).first();
  }
};

// src/modals/MediaDbSearchResultModal.ts
var MediaDbSearchResultModal = class extends SelectModal {
  constructor(plugin, selectModalOptions) {
    selectModalOptions = Object.assign({}, SELECT_MODAL_OPTIONS_DEFAULT, selectModalOptions);
    super(plugin.app, selectModalOptions.elements, selectModalOptions.multiSelect);
    this.plugin = plugin;
    this.title = selectModalOptions.modalTitle;
    this.description = "Select one or multiple search results.";
    this.addSkipButton = selectModalOptions.skipButton;
    this.busy = false;
    this.sendCallback = false;
  }
  setSubmitCallback(submitCallback) {
    this.submitCallback = submitCallback;
  }
  setCloseCallback(closeCallback) {
    this.closeCallback = closeCallback;
  }
  setSkipCallback(skipCallback) {
    this.skipCallback = skipCallback;
  }
  renderElement(item, el) {
    el.createEl("div", { text: this.plugin.mediaTypeManager.getFileName(item) });
    el.createEl("small", { text: `${item.getSummary()}
` });
    el.createEl("small", { text: `${item.type.toUpperCase() + (item.subType ? ` (${item.subType})` : "")} from ${item.dataSource}` });
  }
  submit() {
    if (!this.busy) {
      this.busy = true;
      this.submitButton.setButtonText("Creating entry...");
      this.submitCallback({ selected: this.selectModalElements.filter((x) => x.isActive()).map((x) => x.value) });
    }
  }
  skip() {
    this.skipButton.setButtonText("Skipping...");
    this.skipCallback();
  }
  onClose() {
    this.closeCallback();
  }
};

// src/utils/ModalHelper.ts
var import_obsidian16 = __toModule(require("obsidian"));

// src/modals/MediaDbPreviewModal.ts
var import_obsidian14 = __toModule(require("obsidian"));
var MediaDbPreviewModal = class extends import_obsidian14.Modal {
  constructor(plugin, previewModalOptions) {
    previewModalOptions = Object.assign({}, PREVIEW_MODAL_DEFAULT_OPTIONS, previewModalOptions);
    super(plugin.app);
    this.plugin = plugin;
    this.title = previewModalOptions.modalTitle;
    this.elements = previewModalOptions.elements;
    this.createNoteOptions = previewModalOptions.createNoteOptions;
    this.markdownComponent = new import_obsidian14.Component();
  }
  setSubmitCallback(submitCallback) {
    this.submitCallback = submitCallback;
  }
  setCloseCallback(closeCallback) {
    this.closeCallback = closeCallback;
  }
  preview() {
    return __async(this, null, function* () {
      const { contentEl } = this;
      contentEl.addClass("media-db-plugin-preview-modal");
      contentEl.createEl("h2", { text: this.title });
      const previewWrapper = contentEl.createDiv({ cls: "media-db-plugin-preview-wrapper" });
      this.markdownComponent.load();
      for (const result of this.elements) {
        previewWrapper.createEl("h3", { text: result.englishTitle });
        const fileDiv = previewWrapper.createDiv({ cls: "media-db-plugin-preview" });
        let fileContent = yield this.plugin.generateMediaDbNoteContents(result, this.createNoteOptions);
        fileContent = `
${fileContent}
`;
        try {
          yield import_obsidian14.MarkdownRenderer.renderMarkdown(fileContent, fileDiv, "", this.markdownComponent);
        } catch (e) {
          console.warn(`mdb | error during rendering of preview`, e);
        }
      }
      contentEl.createDiv({ cls: "media-db-plugin-spacer" });
      const bottomSettingRow = new import_obsidian14.Setting(contentEl);
      bottomSettingRow.addButton((btn) => {
        btn.setButtonText("Cancel");
        btn.onClick(() => this.close());
        btn.buttonEl.addClass("media-db-plugin-button");
        this.cancelButton = btn;
      });
      bottomSettingRow.addButton((btn) => {
        btn.setButtonText("Ok");
        btn.setCta();
        btn.onClick(() => this.submitCallback({ confirmed: true }));
        btn.buttonEl.addClass("media-db-plugin-button");
        this.submitButton = btn;
      });
    });
  }
  onOpen() {
    this.preview();
  }
  onClose() {
    this.markdownComponent.unload();
    this.closeCallback();
  }
};

// src/modals/MediaDbSearchModal.ts
var import_obsidian15 = __toModule(require("obsidian"));
var MediaDbSearchModal = class extends import_obsidian15.Modal {
  constructor(plugin, searchModalOptions) {
    searchModalOptions = Object.assign({}, SEARCH_MODAL_DEFAULT_OPTIONS, searchModalOptions);
    super(plugin.app);
    this.plugin = plugin;
    this.selectedTypes = [];
    this.title = searchModalOptions.modalTitle;
    this.query = searchModalOptions.prefilledSearchString;
    for (const mediaType of MEDIA_TYPES) {
      this.selectedTypes.push({ name: mediaType, selected: searchModalOptions.preselectedTypes.contains(mediaType) });
    }
  }
  setSubmitCallback(submitCallback) {
    this.submitCallback = submitCallback;
  }
  setCloseCallback(closeCallback) {
    this.closeCallback = closeCallback;
  }
  keyPressCallback(event) {
    if (event.key === "Enter") {
      this.search();
    }
  }
  search() {
    return __async(this, null, function* () {
      if (!this.query || this.query.length < 3) {
        new import_obsidian15.Notice("MDB | Query too short");
        return;
      }
      const types = this.selectedTypes.filter((x) => x.selected).map((x) => x.name);
      if (types.length === 0) {
        new import_obsidian15.Notice("MDB | No Type selected");
        return;
      }
      if (!this.isBusy) {
        this.isBusy = true;
        this.searchBtn.setDisabled(false);
        this.searchBtn.setButtonText("Searching...");
        this.submitCallback({ query: this.query, types });
      }
    });
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: this.title });
    const placeholder = "Search by title";
    const searchComponent = new import_obsidian15.TextComponent(contentEl);
    searchComponent.inputEl.style.width = "100%";
    searchComponent.setPlaceholder(placeholder);
    searchComponent.setValue(this.query);
    searchComponent.onChange((value) => this.query = value);
    searchComponent.inputEl.addEventListener("keydown", this.keyPressCallback.bind(this));
    contentEl.appendChild(searchComponent.inputEl);
    searchComponent.inputEl.focus();
    contentEl.createDiv({ cls: "media-db-plugin-spacer" });
    contentEl.createEl("h3", { text: "APIs to search" });
    for (const mediaType of MEDIA_TYPES) {
      const apiToggleListElementWrapper = contentEl.createEl("div", { cls: "media-db-plugin-list-wrapper" });
      const apiToggleTextWrapper = apiToggleListElementWrapper.createEl("div", { cls: "media-db-plugin-list-text-wrapper" });
      apiToggleTextWrapper.createEl("span", { text: unCamelCase(mediaType), cls: "media-db-plugin-list-text" });
      const apiToggleComponentWrapper = apiToggleListElementWrapper.createEl("div", { cls: "media-db-plugin-list-toggle" });
      const apiToggleComponent = new import_obsidian15.ToggleComponent(apiToggleComponentWrapper);
      apiToggleComponent.setTooltip(unCamelCase(mediaType));
      apiToggleComponent.setValue(this.selectedTypes.find((x) => x.name === mediaType).selected);
      apiToggleComponent.onChange((value) => {
        this.selectedTypes.find((x) => x.name === mediaType).selected = value;
      });
      apiToggleComponentWrapper.appendChild(apiToggleComponent.toggleEl);
    }
    contentEl.createDiv({ cls: "media-db-plugin-spacer" });
    new import_obsidian15.Setting(contentEl).addButton((btn) => {
      btn.setButtonText("Cancel");
      btn.onClick(() => this.close());
      btn.buttonEl.addClass("media-db-plugin-button");
    }).addButton((btn) => {
      btn.setButtonText("Ok");
      btn.setCta();
      btn.onClick(() => {
        this.search();
      });
      btn.buttonEl.addClass("media-db-plugin-button");
      this.searchBtn = btn;
    });
  }
  onClose() {
    this.closeCallback();
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/utils/ModalHelper.ts
var ModalResultCode;
(function(ModalResultCode2) {
  ModalResultCode2[ModalResultCode2["SUCCESS"] = 0] = "SUCCESS";
  ModalResultCode2[ModalResultCode2["SKIP"] = 1] = "SKIP";
  ModalResultCode2[ModalResultCode2["CLOSE"] = 2] = "CLOSE";
  ModalResultCode2[ModalResultCode2["ERROR"] = 3] = "ERROR";
})(ModalResultCode || (ModalResultCode = {}));
var SEARCH_MODAL_DEFAULT_OPTIONS = {
  modalTitle: "Media DB Search",
  preselectedTypes: [],
  prefilledSearchString: ""
};
var ADVANCED_SEARCH_MODAL_DEFAULT_OPTIONS = {
  modalTitle: "Media DB Advanced Search",
  preselectedAPIs: [],
  prefilledSearchString: ""
};
var ID_SEARCH_MODAL_DEFAULT_OPTIONS = {
  modalTitle: "Media DB Id Search",
  preselectedAPI: "",
  prefilledSearchString: ""
};
var SELECT_MODAL_OPTIONS_DEFAULT = {
  modalTitle: "Media DB Search Results",
  elements: [],
  multiSelect: true,
  skipButton: false
};
var PREVIEW_MODAL_DEFAULT_OPTIONS = {
  modalTitle: "Media DB Preview",
  elements: [],
  createNoteOptions: { attachTemplate: true }
};
var ModalHelper = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  createSearchModal(searchModalOptions) {
    return __async(this, null, function* () {
      const modal = new MediaDbSearchModal(this.plugin, searchModalOptions);
      const res = yield new Promise((resolve) => {
        modal.setSubmitCallback((res2) => resolve({ code: 0, data: res2 }));
        modal.setCloseCallback((err) => {
          if (err) {
            resolve({ code: 3, error: err });
          }
          resolve({ code: 2 });
        });
        modal.open();
      });
      return { searchModalResult: res, searchModal: modal };
    });
  }
  openSearchModal(searchModalOptions, submitCallback) {
    return __async(this, null, function* () {
      const { searchModalResult, searchModal } = yield this.createSearchModal(searchModalOptions);
      console.debug(`MDB | searchModal closed with code ${searchModalResult.code}`);
      if (searchModalResult.code === 3) {
        console.warn(searchModalResult.error);
        new import_obsidian16.Notice(searchModalResult.error.toString());
        searchModal.close();
        return void 0;
      }
      if (searchModalResult.code === 2) {
        return void 0;
      }
      try {
        const callbackRes = yield submitCallback(searchModalResult.data);
        searchModal.close();
        return callbackRes;
      } catch (e) {
        console.warn(e);
        new import_obsidian16.Notice(e.toString());
        searchModal.close();
        return void 0;
      }
    });
  }
  createAdvancedSearchModal(advancedSearchModalOptions) {
    return __async(this, null, function* () {
      const modal = new MediaDbAdvancedSearchModal(this.plugin, advancedSearchModalOptions);
      const res = yield new Promise((resolve) => {
        modal.setSubmitCallback((res2) => resolve({ code: 0, data: res2 }));
        modal.setCloseCallback((err) => {
          if (err) {
            resolve({ code: 3, error: err });
          }
          resolve({ code: 2 });
        });
        modal.open();
      });
      return { advancedSearchModalResult: res, advancedSearchModal: modal };
    });
  }
  openAdvancedSearchModal(advancedSearchModalOptions, submitCallback) {
    return __async(this, null, function* () {
      const { advancedSearchModalResult, advancedSearchModal } = yield this.createAdvancedSearchModal(advancedSearchModalOptions);
      console.debug(`MDB | advencedSearchModal closed with code ${advancedSearchModalResult.code}`);
      if (advancedSearchModalResult.code === 3) {
        console.warn(advancedSearchModalResult.error);
        new import_obsidian16.Notice(advancedSearchModalResult.error.toString());
        advancedSearchModal.close();
        return void 0;
      }
      if (advancedSearchModalResult.code === 2) {
        return void 0;
      }
      try {
        const callbackRes = yield submitCallback(advancedSearchModalResult.data);
        advancedSearchModal.close();
        return callbackRes;
      } catch (e) {
        console.warn(e);
        new import_obsidian16.Notice(e.toString());
        advancedSearchModal.close();
        return void 0;
      }
    });
  }
  createIdSearchModal(idSearchModalOptions) {
    return __async(this, null, function* () {
      const modal = new MediaDbIdSearchModal(this.plugin, idSearchModalOptions);
      const res = yield new Promise((resolve) => {
        modal.setSubmitCallback((res2) => resolve({ code: 0, data: res2 }));
        modal.setCloseCallback((err) => {
          if (err) {
            resolve({ code: 3, error: err });
          }
          resolve({ code: 2 });
        });
        modal.open();
      });
      return { idSearchModalResult: res, idSearchModal: modal };
    });
  }
  openIdSearchModal(idSearchModalOptions, submitCallback) {
    return __async(this, null, function* () {
      const { idSearchModalResult, idSearchModal } = yield this.createIdSearchModal(idSearchModalOptions);
      console.debug(`MDB | idSearchModal closed with code ${idSearchModalResult.code}`);
      if (idSearchModalResult.code === 3) {
        console.warn(idSearchModalResult.error);
        new import_obsidian16.Notice(idSearchModalResult.error.toString());
        idSearchModal.close();
        return void 0;
      }
      if (idSearchModalResult.code === 2) {
        return void 0;
      }
      try {
        const callbackRes = yield submitCallback(idSearchModalResult.data);
        idSearchModal.close();
        return callbackRes;
      } catch (e) {
        console.warn(e);
        new import_obsidian16.Notice(e.toString());
        idSearchModal.close();
        return void 0;
      }
    });
  }
  createSelectModal(selectModalOptions) {
    return __async(this, null, function* () {
      const modal = new MediaDbSearchResultModal(this.plugin, selectModalOptions);
      const res = yield new Promise((resolve) => {
        modal.setSubmitCallback((res2) => resolve({ code: 0, data: res2 }));
        modal.setSkipCallback(() => resolve({ code: 1 }));
        modal.setCloseCallback((err) => {
          if (err) {
            resolve({ code: 3, error: err });
          }
          resolve({ code: 2 });
        });
        modal.open();
      });
      return { selectModalResult: res, selectModal: modal };
    });
  }
  openSelectModal(selectModalOptions, submitCallback) {
    return __async(this, null, function* () {
      const { selectModalResult, selectModal } = yield this.createSelectModal(selectModalOptions);
      console.debug(`MDB | selectModal closed with code ${selectModalResult.code}`);
      if (selectModalResult.code === 3) {
        console.warn(selectModalResult.error);
        new import_obsidian16.Notice(selectModalResult.error.toString());
        selectModal.close();
        return void 0;
      }
      if (selectModalResult.code === 2) {
        return void 0;
      }
      if (selectModalResult.code === 1) {
        return void 0;
      }
      try {
        const callbackRes = yield submitCallback(selectModalResult.data);
        selectModal.close();
        return callbackRes;
      } catch (e) {
        console.warn(e);
        new import_obsidian16.Notice(e.toString());
        selectModal.close();
        return;
      }
    });
  }
  createPreviewModal(previewModalOptions) {
    return __async(this, null, function* () {
      const modal = new MediaDbPreviewModal(this.plugin, previewModalOptions);
      const res = yield new Promise((resolve) => {
        modal.setSubmitCallback((res2) => resolve({ code: 0, data: res2 }));
        modal.setCloseCallback((err) => {
          if (err) {
            resolve({ code: 3, error: err });
          }
          resolve({ code: 2 });
        });
        modal.open();
      });
      return { previewModalResult: res, previewModal: modal };
    });
  }
  openPreviewModal(previewModalOptions, submitCallback) {
    return __async(this, null, function* () {
      const { previewModalResult, previewModal } = yield this.createPreviewModal(previewModalOptions);
      console.debug(`MDB | previewModal closed with code ${previewModalResult.code}`);
      if (previewModalResult.code === 3) {
        console.warn(previewModalResult.error);
        new import_obsidian16.Notice(previewModalResult.error.toString());
        previewModal.close();
        return void 0;
      }
      if (previewModalResult.code === 2) {
        return void 0;
      }
      try {
        const callbackRes = yield submitCallback(previewModalResult.data);
        previewModal.close();
        return callbackRes;
      } catch (e) {
        console.warn(e);
        new import_obsidian16.Notice(e.toString());
        previewModal.close();
        return;
      }
    });
  }
};

// src/main.ts
var MediaDbPlugin = class extends import_obsidian17.Plugin {
  constructor() {
    super(...arguments);
    this.frontMatterRexExpPattern = "^(---)\\n[\\s\\S]*?\\n---";
  }
  onload() {
    return __async(this, null, function* () {
      this.apiManager = new APIManager();
      this.apiManager.registerAPI(new OMDbAPI(this));
      this.apiManager.registerAPI(new MALAPI(this));
      this.apiManager.registerAPI(new WikipediaAPI(this));
      this.apiManager.registerAPI(new MusicBrainzAPI(this));
      this.apiManager.registerAPI(new SteamAPI(this));
      this.apiManager.registerAPI(new BoardGameGeekAPI(this));
      this.mediaTypeManager = new MediaTypeManager();
      this.modelPropertyMapper = new PropertyMapper(this);
      this.modalHelper = new ModalHelper(this);
      yield this.loadSettings();
      this.addSettingTab(new MediaDbSettingTab(this.app, this));
      this.mediaTypeManager.updateTemplates(this.settings);
      this.mediaTypeManager.updateFolders(this.settings);
      const ribbonIconEl = this.addRibbonIcon("database", "Add new Media DB entry", () => this.createEntryWithAdvancedSearchModal());
      ribbonIconEl.addClass("obsidian-media-db-plugin-ribbon-class");
      this.registerEvent(this.app.workspace.on("file-menu", (menu, file) => {
        if (file instanceof import_obsidian17.TFolder) {
          menu.addItem((item) => {
            item.setTitle("Import folder as Media DB entries").setIcon("database").onClick(() => this.createEntriesFromFolder(file));
          });
        }
      }));
      this.addCommand({
        id: "open-media-db-search-modal",
        name: "Create Media DB entry",
        callback: () => this.createEntryWithSearchModal()
      });
      for (const mediaType of MEDIA_TYPES) {
        this.addCommand({
          id: `open-media-db-search-modal-with-${mediaType}`,
          name: `Create Media DB entry (${unCamelCase(mediaType)})`,
          callback: () => this.createEntryWithSearchModal({ preselectedTypes: [mediaType] })
        });
      }
      this.addCommand({
        id: "open-media-db-advanced-search-modal",
        name: "Create Media DB entry (advanced search)",
        callback: () => this.createEntryWithAdvancedSearchModal()
      });
      this.addCommand({
        id: "open-media-db-id-search-modal",
        name: "Create Media DB entry by id",
        callback: () => this.createEntryWithIdSearchModal()
      });
      this.addCommand({
        id: "update-media-db-note",
        name: "Update open note (this will recreate the note)",
        checkCallback: (checking) => {
          if (!this.app.workspace.getActiveFile()) {
            return false;
          }
          if (!checking) {
            this.updateActiveNote(false);
          }
          return true;
        }
      });
      this.addCommand({
        id: "update-media-db-note-metadata",
        name: "Update metadata",
        checkCallback: (checking) => {
          if (!this.app.workspace.getActiveFile()) {
            return false;
          }
          if (!checking) {
            this.updateActiveNote(true);
          }
          return true;
        }
      });
      this.addCommand({
        id: "add-media-db-link",
        name: "Insert link",
        checkCallback: (checking) => {
          if (!this.app.workspace.getActiveFile()) {
            return false;
          }
          if (!checking) {
            this.createLinkWithSearchModal();
          }
          return true;
        }
      });
    });
  }
  createLinkWithSearchModal() {
    return __async(this, null, function* () {
      const apiSearchResults = yield this.modalHelper.openAdvancedSearchModal({}, (advancedSearchModalData) => __async(this, null, function* () {
        return yield this.apiManager.query(advancedSearchModalData.query, advancedSearchModalData.apis);
      }));
      if (!apiSearchResults) {
        return;
      }
      const selectResults = yield this.modalHelper.openSelectModal({ elements: apiSearchResults, multiSelect: false }, (selectModalData) => __async(this, null, function* () {
        return yield this.queryDetails(selectModalData.selected);
      }));
      if (!selectResults || selectResults.length < 1) {
        return;
      }
      const link = `[${selectResults[0].title}](${selectResults[0].url})`;
      const view = this.app.workspace.getActiveViewOfType(import_obsidian17.MarkdownView);
      if (view) {
        view.editor.replaceRange(link, view.editor.getCursor());
      }
    });
  }
  createEntryWithSearchModal(searchModalOptions) {
    return __async(this, null, function* () {
      let types = [];
      let apiSearchResults = yield this.modalHelper.openSearchModal(searchModalOptions != null ? searchModalOptions : {}, (searchModalData) => __async(this, null, function* () {
        types = searchModalData.types;
        const apis = this.apiManager.apis.filter((x) => x.hasTypeOverlap(searchModalData.types)).map((x) => x.apiName);
        return yield this.apiManager.query(searchModalData.query, apis);
      }));
      if (!apiSearchResults) {
        return;
      }
      apiSearchResults = apiSearchResults.filter((x) => types.contains(x.type));
      let selectResults;
      let proceed;
      while (!proceed) {
        selectResults = yield this.modalHelper.openSelectModal({ elements: apiSearchResults }, (selectModalData) => __async(this, null, function* () {
          return yield this.queryDetails(selectModalData.selected);
        }));
        if (!selectResults) {
          return;
        }
        proceed = yield this.modalHelper.openPreviewModal({ elements: selectResults }, (previewModalData) => __async(this, null, function* () {
          return previewModalData.confirmed;
        }));
      }
      yield this.createMediaDbNotes(selectResults);
    });
  }
  createEntryWithAdvancedSearchModal() {
    return __async(this, null, function* () {
      const apiSearchResults = yield this.modalHelper.openAdvancedSearchModal({}, (advancedSearchModalData) => __async(this, null, function* () {
        return yield this.apiManager.query(advancedSearchModalData.query, advancedSearchModalData.apis);
      }));
      if (!apiSearchResults) {
        return;
      }
      let selectResults;
      let proceed;
      while (!proceed) {
        selectResults = yield this.modalHelper.openSelectModal({ elements: apiSearchResults }, (selectModalData) => __async(this, null, function* () {
          return yield this.queryDetails(selectModalData.selected);
        }));
        if (!selectResults) {
          return;
        }
        proceed = yield this.modalHelper.openPreviewModal({ elements: selectResults }, (previewModalData) => __async(this, null, function* () {
          return previewModalData.confirmed;
        }));
      }
      yield this.createMediaDbNotes(selectResults);
    });
  }
  createEntryWithIdSearchModal() {
    return __async(this, null, function* () {
      let idSearchResult;
      let proceed;
      while (!proceed) {
        idSearchResult = yield this.modalHelper.openIdSearchModal({}, (idSearchModalData) => __async(this, null, function* () {
          return yield this.apiManager.queryDetailedInfoById(idSearchModalData.query, idSearchModalData.api);
        }));
        if (!idSearchResult) {
          return;
        }
        proceed = yield this.modalHelper.openPreviewModal({ elements: [idSearchResult] }, (previewModalData) => __async(this, null, function* () {
          return previewModalData.confirmed;
        }));
      }
      yield this.createMediaDbNoteFromModel(idSearchResult, { attachTemplate: true, openNote: true });
    });
  }
  createMediaDbNotes(models, attachFile) {
    return __async(this, null, function* () {
      for (const model of models) {
        yield this.createMediaDbNoteFromModel(model, { attachTemplate: true, attachFile });
      }
    });
  }
  queryDetails(models) {
    return __async(this, null, function* () {
      const detailModels = [];
      for (const model of models) {
        try {
          detailModels.push(yield this.apiManager.queryDetailedInfo(model));
        } catch (e) {
          console.warn(e);
          new import_obsidian17.Notice(e.toString());
        }
      }
      return detailModels;
    });
  }
  createMediaDbNoteFromModel(mediaTypeModel, options) {
    return __async(this, null, function* () {
      try {
        console.debug("MDB | creating new note");
        const fileContent = yield this.generateMediaDbNoteContents(mediaTypeModel, options);
        if (!options.folder) {
          options.folder = yield this.mediaTypeManager.getFolder(mediaTypeModel, this.app);
        }
        yield this.createNote(this.mediaTypeManager.getFileName(mediaTypeModel), fileContent, options);
      } catch (e) {
        console.warn(e);
        new import_obsidian17.Notice(e.toString());
      }
    });
  }
  generateMediaDbNoteContents(mediaTypeModel, options) {
    return __async(this, null, function* () {
      let fileMetadata = this.modelPropertyMapper.convertObject(mediaTypeModel.toMetaDataObject());
      let fileContent = "";
      const template = options.attachTemplate ? yield this.mediaTypeManager.getTemplate(mediaTypeModel, this.app) : "";
      ({ fileMetadata, fileContent } = yield this.attachFile(fileMetadata, fileContent, options.attachFile));
      ({ fileMetadata, fileContent } = yield this.attachTemplate(fileMetadata, fileContent, template));
      fileContent = `---
${this.settings.useCustomYamlStringifier ? YAMLConverter.toYaml(fileMetadata) : (0, import_obsidian17.stringifyYaml)(fileMetadata)}---
` + fileContent;
      return fileContent;
    });
  }
  attachFile(fileMetadata, fileContent, fileToAttach) {
    return __async(this, null, function* () {
      if (!fileToAttach) {
        return { fileMetadata, fileContent };
      }
      const attachFileMetadata = this.getMetadataFromFileCache(fileToAttach);
      fileMetadata = Object.assign(attachFileMetadata, fileMetadata);
      let attachFileContent = yield this.app.vault.read(fileToAttach);
      const regExp = new RegExp(this.frontMatterRexExpPattern);
      attachFileContent = attachFileContent.replace(regExp, "");
      attachFileContent = attachFileContent.startsWith("\n") ? attachFileContent.substring(1) : attachFileContent;
      fileContent += attachFileContent;
      return { fileMetadata, fileContent };
    });
  }
  attachTemplate(fileMetadata, fileContent, template) {
    return __async(this, null, function* () {
      if (!template) {
        return { fileMetadata, fileContent };
      }
      const templateMetadata = this.getMetaDataFromFileContent(template);
      fileMetadata = Object.assign(templateMetadata, fileMetadata);
      const regExp = new RegExp(this.frontMatterRexExpPattern);
      const attachFileContent = template.replace(regExp, "");
      fileContent += attachFileContent;
      return { fileMetadata, fileContent };
    });
  }
  getMetaDataFromFileContent(fileContent) {
    let metadata;
    const regExp = new RegExp(this.frontMatterRexExpPattern);
    const frontMatterRegExpResult = regExp.exec(fileContent);
    if (!frontMatterRegExpResult) {
      return {};
    }
    let frontMatter = frontMatterRegExpResult[0];
    if (!frontMatter) {
      return {};
    }
    frontMatter = frontMatter.substring(4);
    frontMatter = frontMatter.substring(0, frontMatter.length - 3);
    metadata = (0, import_obsidian17.parseYaml)(frontMatter);
    if (!metadata) {
      metadata = {};
    }
    console.debug(`MDB | metadata read from file content`, metadata);
    return metadata;
  }
  getMetadataFromFileCache(file) {
    let metadata = this.app.metadataCache.getFileCache(file).frontmatter;
    if (metadata) {
      metadata = Object.assign({}, metadata);
      delete metadata.position;
    } else {
      metadata = {};
    }
    return metadata;
  }
  createNote(fileName, fileContent, options) {
    return __async(this, null, function* () {
      var _a;
      const folder = (_a = options.folder) != null ? _a : this.app.vault.getAbstractFileByPath("/");
      fileName = replaceIllegalFileNameCharactersInString(fileName);
      const filePath = `${folder.path}/${fileName}.md`;
      const file = this.app.vault.getAbstractFileByPath(filePath);
      if (file) {
        yield this.app.vault.delete(file);
      }
      const targetFile = yield this.app.vault.create(filePath, fileContent);
      console.debug(`MDB | created new file at ${filePath}`);
      if (options.openNote) {
        const activeLeaf = this.app.workspace.getUnpinnedLeaf();
        if (!activeLeaf) {
          console.warn("MDB | no active leaf, not opening newly created note");
          return;
        }
        yield activeLeaf.openFile(targetFile, { state: { mode: "source" } });
      }
    });
  }
  updateActiveNote(onlyMetadata = false) {
    return __async(this, null, function* () {
      const activeFile = this.app.workspace.getActiveFile();
      if (!activeFile) {
        throw new Error("MDB | there is no active note");
      }
      let metadata = this.getMetadataFromFileCache(activeFile);
      metadata = this.modelPropertyMapper.convertObjectBack(metadata);
      console.debug(`MDB | read metadata`, metadata);
      if (!(metadata == null ? void 0 : metadata.type) || !(metadata == null ? void 0 : metadata.dataSource) || !(metadata == null ? void 0 : metadata.id)) {
        throw new Error("MDB | active note is not a Media DB entry or is missing metadata");
      }
      const oldMediaTypeModel = this.mediaTypeManager.createMediaTypeModelFromMediaType(metadata, metadata.type);
      let newMediaTypeModel = yield this.apiManager.queryDetailedInfoById(metadata.id, metadata.dataSource);
      if (!newMediaTypeModel) {
        return;
      }
      newMediaTypeModel = Object.assign(oldMediaTypeModel, newMediaTypeModel.getWithOutUserData());
      console.debug("MDB | deleting old entry");
      if (onlyMetadata) {
        yield this.createMediaDbNoteFromModel(newMediaTypeModel, { attachFile: activeFile, folder: activeFile.parent, openNote: true });
      } else {
        yield this.createMediaDbNoteFromModel(newMediaTypeModel, { attachTemplate: true, folder: activeFile.parent, openNote: true });
      }
    });
  }
  createEntriesFromFolder(folder) {
    return __async(this, null, function* () {
      const erroredFiles = [];
      let canceled = false;
      const { selectedAPI, titleFieldName, appendContent } = yield new Promise((resolve) => {
        new MediaDbFolderImportModal(this.app, this, (selectedAPI2, titleFieldName2, appendContent2) => {
          resolve({ selectedAPI: selectedAPI2, titleFieldName: titleFieldName2, appendContent: appendContent2 });
        }).open();
      });
      for (const child of folder.children) {
        if (child instanceof import_obsidian17.TFile) {
          const file = child;
          if (canceled) {
            erroredFiles.push({ filePath: file.path, error: "user canceled" });
            continue;
          }
          const metadata = this.getMetadataFromFileCache(file);
          const title = metadata[titleFieldName];
          if (!title) {
            erroredFiles.push({ filePath: file.path, error: `metadata field '${titleFieldName}' not found or empty` });
            continue;
          }
          let results = [];
          try {
            results = yield this.apiManager.query(title, [selectedAPI]);
          } catch (e) {
            erroredFiles.push({ filePath: file.path, error: e.toString() });
            continue;
          }
          if (!results || results.length === 0) {
            erroredFiles.push({ filePath: file.path, error: `no search results` });
            continue;
          }
          const { selectModalResult, selectModal } = yield this.modalHelper.createSelectModal({ elements: results, skipButton: true, modalTitle: `Results for '${title}'` });
          if (selectModalResult.code === ModalResultCode.ERROR) {
            erroredFiles.push({ filePath: file.path, error: selectModalResult.error.message });
            selectModal.close();
            continue;
          }
          if (selectModalResult.code === ModalResultCode.CLOSE) {
            erroredFiles.push({ filePath: file.path, error: "user canceled" });
            selectModal.close();
            canceled = true;
            continue;
          }
          if (selectModalResult.code === ModalResultCode.SKIP) {
            erroredFiles.push({ filePath: file.path, error: "user skipped" });
            selectModal.close();
            continue;
          }
          if (selectModalResult.data.selected.length === 0) {
            erroredFiles.push({ filePath: file.path, error: `no search results selected` });
            continue;
          }
          const detailedResults = yield this.queryDetails(selectModalResult.data.selected);
          yield this.createMediaDbNotes(detailedResults, appendContent ? file : null);
          selectModal.close();
        }
      }
      if (erroredFiles.length > 0) {
        yield this.createErroredFilesReport(erroredFiles);
      }
    });
  }
  createErroredFilesReport(erroredFiles) {
    return __async(this, null, function* () {
      const title = `MDB - bulk import error report ${dateTimeToString(new Date())}`;
      const filePath = `${title}.md`;
      const table = [["file", "error"]].concat(erroredFiles.map((x) => [x.filePath, x.error]));
      const fileContent = `# ${title}

${markdownTable(table)}`;
      yield this.app.vault.create(filePath, fileContent);
    });
  }
  loadSettings() {
    return __async(this, null, function* () {
      const diskSettings = yield this.loadData();
      const defaultSettings = getDefaultSettings(this);
      const loadedSettings = Object.assign({}, defaultSettings, diskSettings);
      const newPropertyMappings = [];
      for (const defaultPropertyMappingModel of defaultSettings.propertyMappingModels) {
        const newPropertyMappingModel = loadedSettings.propertyMappingModels.find((x) => x.type === defaultPropertyMappingModel.type);
        if (newPropertyMappingModel === void 0) {
          newPropertyMappings.push(defaultPropertyMappingModel);
        } else {
          const newProperties = [];
          for (const defaultProperty of defaultPropertyMappingModel.properties) {
            const newProperty = newPropertyMappingModel.properties.find((x) => x.property === defaultProperty.property);
            if (newProperty === void 0) {
              newProperties.push(defaultProperty);
            } else {
              newProperties.push(new PropertyMapping(newProperty.property, newProperty.newProperty, newProperty.mapping, defaultProperty.locked));
            }
          }
          newPropertyMappings.push(new PropertyMappingModel(newPropertyMappingModel.type, newProperties));
        }
      }
      loadedSettings.propertyMappingModels = newPropertyMappings;
      this.settings = loadedSettings;
    });
  }
  saveSettings() {
    return __async(this, null, function* () {
      this.mediaTypeManager.updateTemplates(this.settings);
      this.mediaTypeManager.updateFolders(this.settings);
      yield this.saveData(this.settings);
    });
  }
};
